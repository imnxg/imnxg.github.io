{"meta":{"title":"Keney","subtitle":"kenenyの博客","description":"本科 | 计算机科学与技术 | 软件开发","author":"keney","url":"http://www.nnxx.me","root":"/"},"pages":[{"title":"404","date":"2019-08-10T16:41:10.000Z","updated":"2023-04-23T09:04:14.510Z","comments":true,"path":"404.html","permalink":"http://www.nnxx.me/404.html","excerpt":"","text":""},{"title":"","date":"2023-04-23T09:04:14.582Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.nnxx.me/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2023-04-23T09:04:14.582Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.nnxx.me/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T16:41:10.000Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/index.html","permalink":"http://www.nnxx.me/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2021-01-16T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"about/index.html","permalink":"http://www.nnxx.me/about/index.html","excerpt":"","text":"博客一个专注分享IT相关内容的博客,欢迎大家一起交流学习！ 关于我对有趣的事情感兴趣，并且投入的时间比较多，也多行走在互联网世界中，它是一个很奇妙的地方，善于用好它是有必要的。虽然在这世界中，你可以接触到各种各样的信息和知识，这会带给我们带来更多的乐趣和机遇，并且不断地让我们感到兴奋和激动，但是保护好自己（隐私）也是很有必要的。 联系方式Email: mynxg@qq.com"},{"title":"archives","date":"2021-01-16T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"archives/index.html","permalink":"http://www.nnxx.me/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-01-16T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"categories/index.html","permalink":"http://www.nnxx.me/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2021-01-16T10:11:28.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"census/index.html","permalink":"http://www.nnxx.me/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-01-16T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"contact/index.html","permalink":"http://www.nnxx.me/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 keneyの友链信息 博客名称: keneyの博客 博客网址: http://www.nnxx.me 博客头像: https://pic.imgdb.cn/item/640c8a10f144a01007930821.webp 博客介绍: 不积跬步无以至千里"},{"title":"友链","date":"2021-01-16T16:42:10.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"friends/index.html","permalink":"http://www.nnxx.me/friends/index.html","excerpt":"","text":""},{"title":"导航","date":"2021-01-16T11:52:34.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"navigate/index.html","permalink":"http://www.nnxx.me/navigate/index.html","excerpt":"","text":""},{"title":"时间线","date":"2023-04-01T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"record/index.html","permalink":"http://www.nnxx.me/record/index.html","excerpt":"","text":"2023-04-01 2.0.0 -&gt; 2.0.1 新增了在页脚加上 GitHub badge Matery 主题个性化修改篇新增了外挂标签—&gt;时间线 参考添加了动态诗词，关闭了subtitle 参考修复了夜间模式，标签背景白色没适配问题其他小问题修改； 2020-11-27 1.3.2 -&gt; 2.0.0 新增了对 Hexo 5.0.0 的支持，并推荐升级使用 Hexo 5.0.0，去除了对 hexo-prism-plugin 插件的依赖，可直接使用自带的 prismjs 插件； 新增了背景图功能； 新增了畅言、腾讯兔小巢、哔哔、 Artitalk 等评论或说说功能； 开始阅读部分行为修改； 修改了 TOC 目录高度为自适应； 修复了搜索的相关问题； 其他小问题修改； 2020-08-30 1.3.1 -&gt; 1.3.2 新增了繁体字的支持； 新增了 404 页面； 其他小问题修改；"},{"title":"资源分享","date":"2019-07-19T16:40:27.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"resource/index.html","permalink":"http://www.nnxx.me/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-01-16T16:40:27.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"tags/index.html","permalink":"http://www.nnxx.me/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.nnxx.me/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T16:41:10.000Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.nnxx.me/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T16:40:27.000Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/music/index.html","permalink":"http://www.nnxx.me/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T16:40:27.000Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.nnxx.me/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.nnxx.me/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.nnxx.me/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.nnxx.me/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.nnxx.me/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.nnxx.me/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.nnxx.me/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.nnxx.me/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.nnxx.me/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.nnxx.me/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.nnxx.me/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.nnxx.me/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-04-23T09:04:14.514Z","updated":"2023-04-23T09:04:14.514Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.nnxx.me/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"实用工具","slug":"blogtool/tool","date":"2023-04-23T09:04:14.574Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/7450bfcb.html","link":"","permalink":"http://www.nnxx.me/posts/7450bfcb.html","excerpt":"","text":"颜色表晚上的天空配色方案：https://peiseka.com/index-index-peise-id-1232.html","categories":[{"name":"工具","slug":"工具","permalink":"http://www.nnxx.me/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"颜色样式","slug":"颜色样式","permalink":"http://www.nnxx.me/tags/%E9%A2%9C%E8%89%B2%E6%A0%B7%E5%BC%8F/"}],"author":"nxg"},{"title":"frp实现远程桌面连接","slug":"frp/frp实现远程桌面连接","date":"2023-04-20T21:00:00.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/e7d9824f.html","link":"","permalink":"http://www.nnxx.me/posts/e7d9824f.html","excerpt":"","text":"Frp 是一个高性能的反向代理应用程序，它可以帮助您轻松地管理内网中的服务，并且可以将这些服务暴露给公网。Frp 的主要作用是实现内网穿透，使外网用户能够访问内网中的服务。下面是一些 Frp 的应用场景： 内网穿透：通过 Frp，您可以将内网中的服务暴露到公网上，例如 Web 服务器、FTP 服务器、SSH 服务器等。 内网远程桌面：Frp 可以让您在外网使用远程桌面连接到内网中的计算机，方便远程管理和维护。 构建云计算平台：Frp 可以帮助企业构建私有云环境，提供虚拟机、存储和计算资源等服务。 网络监控：Frp 可以用于搭建网络监控系统，通过端口转发将监控服务暴露到公网上，方便管理员远程查看。总之，Frp 是一款十分实用的工具，可以帮助企业和个人轻松地管理和访问内网中的服务。 官网：https://github.com/fatedier/frp/releases/tag/v0.48.0官方文档：https://gofrp.org/docs/setup/systemd/ 一、背景使用todesk个人版(免费)连接远程桌面（win10、win11），在网络环境比较差的情况下，使用起来很不友好，于是就想使用frp这个工具了。 二、前提服务器需要开放安全组规则 例如以我的阿里云服务器为例 具体如何配置请参考： frp实现思路： 首先先明确服务端和客户端是什么？ FRP 中服务端（Server）和客户端（Client）是指 FRP 这个工具的两个不同角色。服务端是 FRP 的远程服务器，它运行在公网上，并且通常被用来提供内网穿透功能。当您需要从外部网络访问内部网络的设备时，可以在公网上部署一个 FRP 服务端，通过配置相应的映射规则，将来自公网的请求转发到内网设备上。客户端是 FRP 工具的本地组件，它运行在需要被访问的内部网络设备上，并与远程服务端建立连接。客户端会向服务端注册自己的身份信息，并定期向服务端发送心跳包以保持连接。一旦客户端成功连接到服务端，外部网络就可以通过服务端访问客户端所在的内部网络设备。 三、环境安装 在 Linux 系统下使用 systemd 控制 frps 及配置开机自启 这里以Linux服务器（centos）为例， 2.1 安装 systemdyum install systemd 2.2 创建并编辑 frps.service 文件（使用vim编辑器）vim /etc/systemd/system/frps.service 2.3 写入内容[Unit] # 服务名称，可自定义 Description = frp server After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动frps的命令，需修改为您的frps的安装路径 # 例如我解压后的frp安装包在此路径下 /root/frp/frps # ExecStart = /root/frp/frps/frps -c /root/frp/frps/frps.ini ExecStart = /path/to/frps -c /path/to/frps.ini [Install] WantedBy = multi-user.target 如下图：上面三步可以参考：https://gofrp.org/docs/setup/systemd/ 2.4 下载解压安装包方式一：在已经创建好的 /root/frp目录下，执行下面的命令即可下frp安装包： wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_arm64.tar.gz 方式二：下载地址：https://github.com/fatedier/frp/releasesLinux版（centos），下载如下图版本： 将frp的linux包传递Linux服务器的自定义目录下 例如：放在/root/frp/目录（文件夹）下，然后解压此文件frp_0.48.0_linux_amd64.tar.gz tar -zxvf frp_0.48.0_linux_amd64.tar.gz 然后对其命名：mv 原文件名 修改后的文件名 mv frp_0.48.0_linux_amd64 frps 或者直接解压并重新命名 2.5 配置服务端（服务器）在解压frp安装包后的文件夹下对文件进行配置： 例如：frp解压在/root/frp/frps/目录下 对frps.ini文件进行配置 vim frps.ini 输入内容： [common] # 服务端端口 bind_port = 7000 binf_addr = 0.0.0.0 bind_udp_port = 7000 authentication_method = token # 认证Token的值包含字母大小写数字等 token = 自定义token # 可视化面板 dashboard_user = admin # Dashboard密码 dashboard_pwd = 123456 dashboard_port = 7500 保存配置并退出 :wq 使用 systemd 命令，管理 frps # 启动frp systemctl start frps # 停止frp systemctl stop frps # 重启frp systemctl restart frps # 查看frp状态 systemctl status frps 配置 frps 开机自启: systemctl enable frps 贴一张可视化面板图： 2.6 配置客户端frp 下载地址：https://github.com/fatedier/frp/releases 自定义一个文件夹解压 2.6 配置客户端（win10本机）在解压frp安装包后，进入找到frpc.ini配置文件并使用文本编辑器打开配置如下： # 全局配置 [common] # 服务端公网ip server_addr = 你的服务端公网ip地址，自行修改 # 服务端端口 server_port = 7000 authentication_method = token token = 自定义token # 反向代理的名称，可以随意设置 [RDP] # RDP 是 TCP 协议的 type = tcp # 本机 IP local_ip = 127.0.0.1 # 远程桌面的默认端口 local_port = 3389 # 外网访问的端口 remote_port = 7001 注意：服务端的配置的token与客户端配置的token需要保持一致。 参考：https://cloud.tencent.com/developer/article/1710141 在目录下输入cmd回车，然后运行frpc.exe如图所示：就此配置完成 接下来就连接远程桌面了 2.7 连接远程桌面如下图所示：计算机为你服务端的ip地址加端口 例如：139.224.12.12:7001（远程连接端口） 由于我电脑使用的微软邮箱，用户名就为 123@outlook.com，密码对应微软邮箱密码如果你使用的是本地账号登录，那用户名就是你本地的那个用户名，密码就是开机密码。 如果不想使用ip地址，可以将ip地址绑到域名上，或不想输入端口，可以进行反向代理 总结总之，frp不仅仅只是玩远程桌面，还可以玩内网穿透、渗透等。 附件参考1：https://cloud.tencent.com/developer/article/1710141参考2：https://www.cnblogs.com/zhanggaoxing/p/9221705.html阿里云官方地址：https://account.aliyun.com/login/login.htm","categories":[{"name":"frp","slug":"frp","permalink":"http://www.nnxx.me/categories/frp/"}],"tags":[{"name":"frp","slug":"frp","permalink":"http://www.nnxx.me/tags/frp/"},{"name":"远程桌面","slug":"远程桌面","permalink":"http://www.nnxx.me/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"}]},{"title":"有趣的项目推荐","slug":"有趣的项目推荐","date":"2023-04-18T21:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"posts/111e0cd7.html","link":"","permalink":"http://www.nnxx.me/posts/111e0cd7.html","excerpt":"","text":"音乐类一起听歌吧多房间版本 示例：多人房间在线听歌","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://www.nnxx.me/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"有趣的项目推荐","slug":"有趣的项目推荐","permalink":"http://www.nnxx.me/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/"}]},{"title":"vuepress-theme-hope主题扩展","slug":"blog/vuepress-theme-hope主题 ","date":"2023-04-09T17:00:00.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/f554e8a6.html","link":"","permalink":"http://www.nnxx.me/posts/f554e8a6.html","excerpt":"","text":"vuepress-theme-hope主题组件的使用在markdown文件里引入组件（容器） 自定义注册组件src.vuepress\\components\\NavCard.vue &lt;template&gt; &lt;el-row :gutter=\"30\"&gt; &lt;el-col :xs=\"24\" :sm=\"24\" :md=\"12\" :lg=\"8\" :xl=\"8\" v-for=\"(cardObj, index) in cardArr\" :key=\"index\" style=\"margin-top:20px;height:100px;width:100%;overflow:auto;\"&gt; &lt;!-- &lt;el-link class=\"link-style\" :underline=\"false\" target=\"_blank\" :href=\"cardObj.url\" &gt; --&gt; &lt;!-- &lt;el-card class=\"box-card\" shadow=\"always\" :body-style=\"{ padding:'5px' }\" &gt; --&gt; &lt;el-card shadow=\"never\" :body-style=\"{ padding: '20px' }\"&gt; &lt;el-row class=\"box-card-header\"&gt; &lt;el-col :xs=\"12\" :sm=\"12\" :md=\"12\" :lg=\"12\" :xl=\"12\" style=\"padding:0px;\"&gt; &lt;img style=\"width:30px;height:30px;text-align:left;\" :src=\"$withBase(cardObj.icon)\" :alt=\"cardObj.title\" /&gt; &lt;/el-col&gt; &lt;el-col :xs=\"12\" :sm=\"12\" :md=\"12\" :lg=\"12\" :xl=\"12\" style=\"padding:0px;\"&gt; &lt;div style=\"text-align:right;\"&gt; &lt;el-tooltip effect=\"dark\" :content=\"cardObj.desc\" placement=\"bottom\"&gt; &lt;el-button :type=\"type\" plain @click.native=\"gotoSite(cardObj.url)\"&gt;{{ cardObj.title }}&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row class=\"box-card-body\"&gt; &lt;div style=\"font-size:10px;color:#999999\"&gt;{{ cardObj.desc }}&lt;/div&gt; &lt;/el-row&gt; &lt;/el-card&gt; &lt;!-- &lt;/el-link&gt; --&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"NavCard\", components: {}, props: { arr: { type: String, default: '' } }, data() { return { cardArr: JSON.parse(this.arr), type: 'success', } }, methods: { gotoSite(url) { // console.log(url); // 在新标签页打开 window.open(url, '_blank').location; }, }, } &lt;/script&gt; &lt;style&gt; .link-style { width: 100%; height: 100%; padding: 0px; } .box-card { width: 100%; height: 100%; } .box-card-header { width: 100%; height: 50%; margin-bottom: 1px; padding: 0px; } .box-card-body { width: 100%; height: 50%; margin-top: 1px; padding: 0px; } .el-card { border-radius: 10px; border: none; background-color: #F6F6F6; box-shadow: 0px 1px 5px 4px #0000001a; } .el-card:hover { transform: scale(1.03); /* boder-top: none; */ /* background-color: #FDF853; */ background-color: #98fb98; }&lt;/style&gt; 创建src.vuepress\\client.ts // 客户端增强配置文件-https://v2.vuepress.vuejs.org/zh/guide/migration.html#%E7%BA%A6%E5%AE%9A%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4 import { defineClientConfig } from \"@vuepress/client\"; import ElementPlus from \"element-plus\"; import \"element-plus/dist/index.css\"; export default defineClientConfig({ enhance: ({ app, router, siteData }) =&gt; { // 引入Element-plus组件库 // 【引入的主要目的不是在MD文档中使用Element的组件，主要是为了编写自己的组件】 // 【自己写的组件被registerComponentsPlugin插件引入全局在进行使用】 app.use(ElementPlus); }, }); 在config.ts插件配置中配置 // 注册全局组件的插件 registerComponentsPlugin({ componentsDir: path.resolve(__dirname, \"./components\"), }), 同时需要在config.ts头部引入 import { registerComponentsPlugin } from \"@vuepress/plugin-register-components\"; import { getDirname, path } from \"@vuepress/utils\"; const __dirname = getDirname(import.meta.url); 这样就可以在src.vuepress\\components文件夹下自由引入相应的组件了 例如引入src.vuepress\\components\\NavCard.vue组件： --- # # 当前页面内容标题 title: 友链 # 当前页面图标 icon: link # 分类 category: - 友链 # 标签 tag: - 博客链接 sticky: false # 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。 star: false # 是否将该文章添加至文章列表中 article: false # 是否将该文章添加至时间线中 --- ## 博客推荐 &lt;NavCard arr='[ {\"title\":\"keney\",\"url\":\"https://nnxx.me/\",\"desc\":\"基于hexo-matery搭建的博客\",\"icon\":\"https://pic.imgdb.cn/item/640d9bf1f144a010073218ac.png\"}&gt;&lt;/NavCard&gt; 效果如下图： 链接src.vuepress\\components\\MyLinks.vue MyLinks.vue &lt;script setup lang=\"ts\"&gt; import { document } from '../data/document.js'; import { friend } from '../data/friend.js'; import { tools } from '../data/tools.js'; const props = defineProps&lt;{ type: string; src: string; }&gt;(); let linkData = document; switch (props.src) { case 'document': linkData = document; break; case 'tools': linkData = tools; break; case 'friend': linkData = friend; break; default: linkData = document; } &lt;/script&gt; &lt;template&gt; &lt;div class=\"MyLinks project-panel\" v-if=\"props.type\"&gt; &lt;template v-if=\"linkData.length &gt; 0\"&gt; &lt;template v-for=\"(item, index) in linkData\"&gt; &lt;a class=\"linkWrapper project\" target=\"_blank\" :class=\"`project${index % 9}`\" :href=\"item.href\" :key=\"index\" v-if=\"item.type.indexOf(props.type) &gt; -1\" &gt; &lt;img class=\"image\" :src=\"item.cover\" /&gt; &lt;div class=\"name\"&gt; {{ item.name }} &lt;/div&gt; &lt;div class=\"desc\"&gt; {{ item.desc }} &lt;/div&gt; &lt;/a&gt; &lt;/template&gt; &lt;/template&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang=\"scss\" scoped&gt; a.linkWrapper { text-decoration: none; } &lt;/style&gt; src.vuepress\\data\\friend.ts export const friend = [ { name: 'keney', desc: '博客', href: 'https://hisnxg.github.io/', cover: '/navicon/r2coding.png', type: ['friend'], }, ]; /* { name: 'xxxx', desc: 'xxxx', href: 'xxxx', cover: 'xxxx', type: ['xxx'], }, */ ahout.md引入： --- icon: youlian --- # 友链 ::: tip 欢迎交换友情链接 ::: &lt;MyLinks type=\"friend\" src=\"friend\"/&gt; --- 效果： 参考：https://github.com/mo7cc/BlogSource 自定义链接src.vuepress\\containers\\projects.ts projects.ts： import yaml from 'js-yaml' import type Token from 'markdown-it/lib/token.js' import { withBase } from '../utils' export interface Project { icon: string name: string desc: string link: string } /** * 渲染容器列表 * @param tokens * @param idx * @returns */ export const renderProjects = (tokens: Token[], idx: number) =&gt; { const { nesting: tokenNesting, info: tokenInfo } = tokens[idx] // 渲染开头的 ':::' 标记 if (tokenNesting === 1) { let yamlStr = '' for (let i = idx; i &lt; tokens.length; i++) { const { type, content, info } = tokens[i] if (type === 'container_projects_close') break if (!content) continue if (type === 'fence' &amp;&amp; info === 'yaml') { // 是代码块类型，并且是yaml代码 yamlStr = content } } if (yamlStr) { const dataObj = yaml.load(yamlStr) // 将yaml字符串解析成js对象 let dataList: Project[] = [] if (dataObj) { // 正确解析出数据对象 if (Array.isArray(dataObj)) { dataList = dataObj } else { dataList = dataObj.data } } // 判断是否有数据 if (dataList &amp;&amp; dataList.length) { const getProjectItem = ( project: Project, index: number, type?: string ) =&gt; { const isFriends = type === 'friends' return ` &lt;a class=\"project project${index % 9}\" href=\"${withBase(project.link)}\" ${isFriends ? '' : 'rel=\"noopener noreferrer\"'} target=\"_blank\"&gt; &lt;img src=\"${withBase(project.icon)}\" alt=\"${project.name}\" class=\"image\" /&gt; &lt;div class=\"name\"&gt;${project.name}&lt;/div&gt; &lt;div class=\"desc\"&gt;${project.desc}&lt;/div&gt; &lt;/a&gt; ` } const getProjects = (projects: Project[], type?: string) =&gt; { let projectsStr = '' projects.map((project, index) =&gt; { projectsStr += getProjectItem(project, index, type) }) return projectsStr } const type = tokenInfo.split(' ').pop() return `&lt;div class=\"project-panel\"&gt;${getProjects(dataList, type)}` } } } else { // 渲染':::' 结尾 return '&lt;/div&gt;' } return '' } 使用自定义容器需要在packge.json中引入依赖包 \"js-yaml\": \"^4.1.0\", src.vuepress\\utils.ts 增加utils.ts export const withBase = (path: string) =&gt; { if (!path) return '' const base = '/' if (base &amp;&amp; path.charAt(0) === '/') { return base + path.slice(1) } else { return path } } src.vuepress\\config.ts 在config.ts中插件配置 // VuePress插件配置 // 自定义容器插件 containerPlugin({ type: 'projects', render: (tokens, idx) =&gt; { return renderProjects(tokens, idx) } }), 注意：在config.ts头部引入 &gt;*// VuePress插件配置* &gt;*// 自定义容器插件* &gt;import { containerPlugin } from '@vuepress/plugin-container' &gt;import { renderProjects } from './containers/projects' 通过yaml方式处理，显示会多出代码块，就需要在自定义样式中隐藏掉 src.vuepress\\styles\\index.scss： .project-panel { a { &amp;:hover { text-decoration: none; } } .project { .image { border-radius: 50%; } } .language-yaml { display: none; } } 在about.md文件中添加 --- toc: false breadcrumb: false --- # 关于本站 一个基于 VuePress 的个人博客。 ## 服务提供 本站由以下内容提供服务 ::: projects ```yaml - icon: https://image.liubing.me/2023/02/11/7f17f3cf426c3.png name: Cloudflare desc: 提供免费的 CDN 服务。 link: https://www.cloudflare.com/ - icon: https://image.liubing.me/2023/02/11/a6de6381e4ae6.png name: Contabo desc: VPS 所属供应商。 link: https://contabo.com/ - icon: https://image.liubing.me/2023/02/11/50994f9710667.ico name: 宝塔 Linux 面板 desc: 用来管理 VPS link: https://cn.vuejs.org/ - icon: https://vuepress.vuejs.org/hero.png name: VuePress desc: 博客驱动引擎。 link: https://vuepress.vuejs.org/zh/ - icon: https://theme-hope.vuejs.press/logo.png name: VuePress Theme Hope desc: 本站博客所用主题 link: https://theme-hope.vuejs.press/zh/ - icon: https://image.liubing.me/2023/02/11/a7643dcbbc234.png name: Buddy desc: 本站自动化打包构建发布工具。 link: https://buddy.works - icon: https://image.liubing.me/2023/02/05/834597e9e927e.png name: Waline desc: 本站评论所用服务。 link: https://waline.js.org/ ``` ::: 效果跟上图一样 功能评论在主题插件中配置： src.vuepress\\theme.ts comment: { provider: \"Waline\", serverURL: \"自己搭建的walineAPI接口地址\", } 效果： 参考：https://github.com/walinejs/waline https://plugin-comment2.vuejs.press/zh/ 订阅插件在主题插件中配置： src.vuepress\\theme.ts //订阅插件SSR feed: { // 插件选项 atom: true, json: true, rss: true, }, 底部页脚（备案信息）在src.vuepress\\theme.ts配置中 const footer_HTML = `&lt;div class=\"container-box\"&gt; &lt;div class=\"footer-btn\"&gt; &lt;a class=\"footer-icp\" href=\"https://beian.miit.gov.cn\" target=\"_blank\"&gt; &lt;img src=\"icp.png\"&gt; 鄂ICP备2021号 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;` 然后启用页脚即可： // 全局设置页脚信息 footer: footer_HTML, // 显示页脚 displayFooter: true, 如果只想局部显示，可以在相应的markdown文件头部添加footer 参考：https://theme-hope.vuejs.press/zh/guide/layout/footer.html 注意如有报错根据提示，引入相应的依赖，一般在package.json中配置。 附件参考： vuepress-theme-hope vuepress-theme-hope仓库：https://github.com/vuepress-theme-hope/vuepress-theme-hope https://github.com/mo7cc/BlogSource https://github.com/liub1934/liubing.me","categories":[{"name":"vuerpess","slug":"vuerpess","permalink":"http://www.nnxx.me/categories/vuerpess/"}],"tags":[{"name":"扩展","slug":"扩展","permalink":"http://www.nnxx.me/tags/%E6%89%A9%E5%B1%95/"},{"name":"vuepress-theme-hope","slug":"vuepress-theme-hope","permalink":"http://www.nnxx.me/tags/vuepress-theme-hope/"}]},{"title":"兰空图床反代问题","slug":"img/兰空图床反代问题","date":"2023-04-09T15:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"posts/a24c5b3d.html","link":"","permalink":"http://www.nnxx.me/posts/a24c5b3d.html","excerpt":"","text":"一、遇到的问题反向代理后出现布局乱了（失效），原因：反代请求问题 二、解决办法 反向代理问题。先修改/config/app.php再从NginxProxyManager里修改对应的Proxy Host。custom locations下添加一个header，内容为：proxy_set_header X-Forwarded-Host $http_host; 如图：不过旧的问题解决了，新的问题又来了，图片路径应该是绑定的域名，而它生成的是之前的ip地址+端口，不过也好解决，直接在兰空图床中修改，即储存策略里有个访问网址，修改成正确域名就行。 附件参考：https+域名+端口的访问问题，NginxProxyManager反代参考：常见问题官网文档：lsky文档GitHub仓库：lsky-pro","categories":[{"name":"图床","slug":"图床","permalink":"http://www.nnxx.me/categories/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"lsky","slug":"lsky","permalink":"http://www.nnxx.me/tags/lsky/"},{"name":"兰空图床","slug":"兰空图床","permalink":"http://www.nnxx.me/tags/%E5%85%B0%E7%A9%BA%E5%9B%BE%E5%BA%8A/"}]},{"title":"PicGo配置多图床仓库","slug":"img/picgo使用多图床","date":"2023-04-08T14:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"posts/7dbd4c.html","link":"","permalink":"http://www.nnxx.me/posts/7dbd4c.html","excerpt":"","text":"背景想使用不需要直接购买服务器就可以存储图片，并且可以很方便使用外链访问到图片资源。这里就有了typora+PicGo两者结合的工具 PicGo配置多图床以七牛云为例： 官网：https://portal.qiniu.com/ 七牛云有10G免费存储空间和10G CDN静态资源加速 注意：CDN超额会需要付费的。 参考此文：配置手册 | PicGo PicGo配置如下图： 个人密钥： 参考：七牛云 - 密钥管理 (qiniu.com) 空间名称： 我自定义的空间名称为：nxg-img 存储区域参考这里：存储区域_产品简介_对象存储 - 七牛开发者中心 (qiniu.com) 图片存储路径： 我使用typora编辑器，就自定义了 typora目录 注意： 自定义域名，免费的的cdn只提供http协议，使用外链域名时，需要填写http，而不是https 网址后缀的作用是：用到了七牛的图片处理工具的时候会用到的一些处理参数，比如图片瘦身 如图： 域名绑定： 自己购买的域名，如果没有可以使用官方提供的。 扩展GitHub图床配置 cdn加速GitHub图床： https://cdn.jsdelivr.net/gh/github用户名/仓库名@主分支/ 例如： https://cdn.jsdelivr.net/gh/imnxg/imgbeds@main/ 参考：GitHub配置 | PicGo gitee图床配置： 参考：https://github.com/lizhuangs/picgo-plugin-gitee-uploader.git 附件参考： GitHub仓库：Molunerfinn/PicGo 配置手册 | PicGo PicGo (molunerfinn.com)","categories":[{"name":"图床","slug":"图床","permalink":"http://www.nnxx.me/categories/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"picgo","slug":"picgo","permalink":"http://www.nnxx.me/tags/picgo/"},{"name":"typora","slug":"typora","permalink":"http://www.nnxx.me/tags/typora/"}]},{"title":"申请免费域名dns解析cdn加速","slug":"cdn-dns/申请免费域名dns解析cdn加速","date":"2023-04-06T19:05:50.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/d85df7a9.html","link":"","permalink":"http://www.nnxx.me/posts/d85df7a9.html","excerpt":"","text":"附件参考：申请免费域名并配置DNS解析及CDN加速 | 倚栏听风 (iweek.eu.org)","categories":[{"name":"域名-cdn-dns","slug":"域名-cdn-dns","permalink":"http://www.nnxx.me/categories/%E5%9F%9F%E5%90%8D-cdn-dns/"}],"tags":[{"name":"cdn","slug":"cdn","permalink":"http://www.nnxx.me/tags/cdn/"},{"name":"dns解析","slug":"dns解析","permalink":"http://www.nnxx.me/tags/dns%E8%A7%A3%E6%9E%90/"}]},{"title":"github代码备份到gitee仓库-工作流","slug":"githubAction/github代码备份到gitee仓库-工作流","date":"2023-04-04T22:10:00.000Z","updated":"2023-04-23T09:04:14.578Z","comments":true,"path":"posts/996e7bfe.html","link":"","permalink":"http://www.nnxx.me/posts/996e7bfe.html","excerpt":"","text":"大概思路从本地（windows）使用git将代码提交到GitHub某仓库，然后触发某仓库GitHub工作流，使其将代码推送到gitee仓库。 前置知识 需要会使用git 熟悉GitHub（配置、工作流） 大致步骤关于GitHub工作流与密钥配置对应图： 1.配置本地密钥到gitee，至于怎么配置可以参考git多账号配置 2.配置GitHub公钥 该公钥要与gitee配置公钥对应上 本地密钥id_rsa_gitee.pub内容复制到GitHub中 粘贴到如下图： 同理将上的公钥复制粘贴到gitee上 配置示例如下： 3.配置GitHub仓库密钥 需要在GitHub仓库添加对应secrets 如下图： 注意：此处的私钥要与gitee配置的公钥成对存在 如下图： 附件参考：yanglbme/gitee-pages-action gitee-pages-action 报错WARNING: StrictHostKeyChecking disabled Cloning into bare repository 'hexo-theme-gitee-blog.git'... SOURCE=git@github.com:hisnxg/hexo-theme-gitee-blog.git DESTINATION=git@gitee.com:hisnxg/hisnxg.git DRY RUN=false Warning: Permanently added 'github.com' (ED25519) to the list of known hosts. git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. fatal: not a git repository (or any parent up to mount point /github) Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set). 原因：gitee配置的此公钥要与GitHub公钥成对存在。 添加即可解决 如未解决可参考：https://github.com/yanglbme/gitee-pages-action/issues/29","categories":[{"name":"运维","slug":"运维","permalink":"http://www.nnxx.me/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.nnxx.me/tags/git/"},{"name":"github工作流","slug":"github工作流","permalink":"http://www.nnxx.me/tags/github%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"butterfly主题扩展","slug":"blog/butterflay主题扩展","date":"2023-04-04T17:00:00.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/b1cab2ec.html","link":"","permalink":"http://www.nnxx.me/posts/b1cab2ec.html","excerpt":"","text":"butterfly主题搭建朋友圈 官方文档：https://fcircle-doc.yyyzyyyz.cn/#/backenddeploy github部署 注意：如果前端部署采用带管理面板的前端方案，则fork时不要修改仓库名称，否则会导致管理面板部分功能不可用。 github+sqlite部署这是默认的部署方式，即：github+sqlite+vercel 评论Twikoo评论 官方文档：https://twikoo.js.org/ 简单 免费搭建（使用云开发 / Vercel / 私有服务器作为评论后台） 简单部署（支持云开发 / Vercel 一键部署） 注意：在阅读官方教程部署时，可能会遇到一些问题。在此简单记录一下，如果你是使用vercel部署，在拉取代码到vercel时，使用的是https://vercel.com/import/project?template=https://github.com/imaegoo/twikoo/tree/main/src/server/vercel-min，这只是twikoo仓库的一个分支，如果你直接fork官方t的wikoo仓库，然后使用vercel部署就会出现问题。 参考：https://blog.zhheo.com/p/2e6bbbd0.html https://butterfly.js.org/posts/ceeb73f/ 附件参考：https://noionion.top/12280.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.nnxx.me/categories/hexo/"}],"tags":[{"name":"butterfly","slug":"butterfly","permalink":"http://www.nnxx.me/tags/butterfly/"},{"name":"扩展","slug":"扩展","permalink":"http://www.nnxx.me/tags/%E6%89%A9%E5%B1%95/"}]},{"title":"hexo-matery主题配置","slug":"matery配置","date":"2023-04-01T18:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"posts/7e0904da.html","link":"","permalink":"http://www.nnxx.me/posts/7e0904da.html","excerpt":"","text":"前置知识 熟悉css 熟悉html 熟悉js 如果你不熟悉上述知识，你只能照搬，并且遇到问题是需要花费大量时间才能解决。对于想对博客进行扩展，这是必备的。 官方文档https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/ 自定义文章创建Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 以下为文章的 Front-matter 示例。 --- title: {{ title }} date: {{ date }} top: false # 文章置顶 cover: false toc: true # 是否显示文章目录 snow: false mathjax: false author: nxg img: sticky: true coverImg: password: summary: # 摘要 category: - hexo tags: - hexo - matery --- 美化扩展适配夜间模式参考：https://cloud.tencent.com/developer/article/1866962 github-badge添加方法： 简单暴力的方法，在 footer.ejs 文件中添加以下内容（在适当的位置添加）： &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"https://hexo.io/\" target=\"_blank\" title=\"由 Hexo 强力驱动\"&gt; &lt;span class=\"badge-subject\"&gt;Powered&lt;/span&gt;&lt;span class=\"badge-value bg-blue\"&gt;Hexo&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"https://github.com/\" target=\"_blank\" title=\"静态网页托管于 GitHub Pages 和 Coding Pages 和 Gitee Pages\"&gt; &lt;span class=\"badge-subject\"&gt;Hosted&lt;/span&gt;&lt;span class=\"badge-value bg-brightgreen\"&gt;GitHub &amp; Coding &amp; Gitee&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"https://cloud.tencent.com/\" target=\"_blank\" title=\"腾讯云提供域名相关服务\"&gt; &lt;span class=\"badge-subject\"&gt;DNS&lt;/span&gt;&lt;span class=\"badge-value bg-blueviolet\"&gt;Tencent&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"https://www.jsdelivr.com/\" target=\"_blank\" title=\"jsDelivr 提供 CDN 加速服务\"&gt; &lt;span class=\"badge-subject\"&gt;CDN&lt;/span&gt;&lt;span class=\"badge-value bg-orange\"&gt;jsDelivr&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"https://blinkfox.github.io/\" target=\"_blank\" title=\"站点使用 Matery主题\"&gt; &lt;span class=\"badge-subject\"&gt;Theme&lt;/span&gt;&lt;span class=\"badge-value bg-blue\"&gt;Matery&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\" title=\"本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可\"&gt; &lt;span class=\"badge-subject\"&gt;&lt;i class=\"fa fa-copyright\"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class=\"badge-value bg-lightgrey\"&gt;BY-NC-SA 4.0&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;a style=\"color: #fff\" rel=\"license\" href=\"https://996.icu/\" target=\"_blank\" title=\"支持 996.ICU\"&gt; &lt;span class=\"badge-subject\"&gt;Link&lt;/span&gt;&lt;span class=\"badge-value bg-red\"&gt;996.ICU&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;span class=\"badge-subject\"&gt;UV&lt;/span&gt;&lt;span class=\"badge-value bg-orange\" id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;span class=\"badge-subject\"&gt;PV&lt;/span&gt;&lt;span class=\"badge-value bg-brightgreen\" id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"github-badge\"&gt; &lt;span class=\"badge-subject\"&gt;WordCount&lt;/span&gt;&lt;span class=\"badge-value bg-blueviolet\"&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 然后添加 css 样式，自己选择代码的添加位置，可以直接放在 footer.ejs 文件中，也可以放在 my.css 文件中，代码如下： /* 在页脚加上 GitHub badge */ .github-badge { display:inline-block; border-radius:4px; text-shadow:none; font-size:13px; color:#fff; line-height:15px; background-color:#ABBAC3; margin-bottom:5px; } .github-badge .badge-subject { display:inline-block; background-color:#4D4D4D; padding:4px 4px 4px 6px; border-top-left-radius:4px; border-bottom-left-radius:4px; } .github-badge .badge-value { display:inline-block; padding:4px 6px 4px 4px; border-top-right-radius:4px; border-bottom-right-radius:4px; } .github-badge .bg-brightgreen { background-color:#4DC820 !important; } .github-badge .bg-orange { background-color:#FFA500 !important; } .github-badge .bg-yellow { background-color:#D8B024 !important; } .github-badge .bg-blueviolet { background-color:#8833D7 !important; } .github-badge .bg-pink { background-color:#F26BAE !important; } .github-badge .bg-red { background-color:#e05d44 !important; } .github-badge .bg-blue { background-color:#007EC6 !important; } .github-badge .bg-lightgrey { background-color:#9F9F9F !important; } .github-badge .bg-grey, .github-badge .bg-gray { background-color:#555 !important; } .github-badge .bg-lightgrey, .github-badge .bg-lightgray { background-color:#9f9f9f !important; } /* 在页脚加上 GitHub badge */ 然后进行本地调试，查看效果即可，本地调试好后，在进行部署的相关操作。 功能扩展Twikoo评论https://twikoo.js.org/quick-start.html#vercel-%E9%83%A8%E7%BD%B2 需要注意，在使用vercel部署时，输出目录为 ./dist/ ,需要自己设置一下 附件Windows 环境下搭建一个 Hexo 博客 Matery 主题个性化修改篇 matery 代码高亮，跳过渲染等问题 hexo增加黑暗模式 关于给hexo博客适配全局深色模式 Matery主题添加暗色模式 –&gt;有效 自定义Matery主题教程 –&gt;有部分参考 Matery主题搭建与优化教程超详细解析 了解Markdown 语法教程","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.nnxx.me/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.nnxx.me/tags/hexo/"},{"name":"matery","slug":"matery","permalink":"http://www.nnxx.me/tags/matery/"}],"author":"nxg"},{"title":"mysql问题","slug":"question","date":"2022-11-17T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"posts/24567d40.html","link":"","permalink":"http://www.nnxx.me/posts/24567d40.html","excerpt":"","text":"问题1-提示1251- Client does not support authentication protocol requested by server原因：mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决办法： 方法1.升级navicat驱动； 方法2.把mysql用户登录密码加密规则还原成mysql_native_password. 使用命令方式解决： 方法1： # 更新user为root，host为% 的密码为123456 ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; # 更新user为root，host为localhost 的密码为123456 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; # 方法2： # 修改加密规则 （这行我没有写，不过貌似也可以） ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; # 更新一下用户的密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; #刷新权限 FLUSH PRIVILEGES; 附件参考：https://blog.csdn.net/pengfeng111833/article/details/124399404 参考2：https://huaweicloud.csdn.net/63355d9ed3efff3090b54464.html","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.nnxx.me/categories/mysql/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://www.nnxx.me/tags/%E5%90%8E%E7%AB%AF/"},{"name":"mysql","slug":"mysql","permalink":"http://www.nnxx.me/tags/mysql/"}],"author":"nxg"},{"title":"centos7.9使用","slug":"linux","date":"2022-11-16T00:00:00.000Z","updated":"2023-04-23T09:04:14.582Z","comments":true,"path":"posts/5baca9db.html","link":"","permalink":"http://www.nnxx.me/posts/5baca9db.html","excerpt":"","text":"一、环境安装1.JDK安装这里安装JDK版本jdk-8u11-linux-x64.tar.gz 注：在登录centos服务器之后切换到根（root）目录下 cd / 1.在root权限下，在根目录下创建文件夹 mkdir -p /usr/local/java 切换到/usr/local/java目录下 cd /usr/local/java 将该jdk-8u11-linux-x64.tar.gz压缩包上传到当前位置 2.解压jdk-8u11-linux-x64.tar.gz压缩包 tar -zxvf ./jdk-8u11-linux-x64.tar.gz -C /usr/local/java/ 然后切换到根目录下 cd / 3.编辑Linux系统中环境变量所在文件 vi /etc/profile 4.在文件最后加入环境变量设置，加入后保存文件 export JAVA_HOME=/usr/local/java/jdk1.8.0_11 #这是自己的jdk所在位置 export CLASSPATH=.:$JAVA_HOME/jre/lib/dt.jar:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 5.让环境变量生效 source /etc/profile 6.测试JDK是否已经配置好 #执行命令 java -version #显示如下 java version \"1.8.0_11\" Java(TM) SE Runtime Environment (build 1.8.0_11-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode) #执行命令 javac-version #显示如下 javac 1.8.0_11 2 .Docker安装在拉去之前，先配置镜像加速器 阿里云镜像获取地址：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了： 因为工作的需要,需要把docker 启动后的路径改成/data,所以就会用到:/etc/docker/daemon.json 是docker 的配置文件,默认是没有的,需要我们手动创建,可配置项如下: #在根目录下 cd / #创建docker目录 mkdir -p /etc/docker # 切换到docker目录下 cd /etc/docker # 创建daemon.json touch daemon.json 然后打开下面的配置文件： # 在根目录下打开该配置文件 vi /etc/docker/daemon.json 在/etc/docker/daemon.json文件末尾增加如下内容： { \"registry-mirrors\": [\"https://你的ID.mirror.aliyuncs.com\"] } 修改完daemon.json文件后，需要让这个文件生效 a.修改完成后reload配置文件 sudo systemctl daemon-reload b.重启docker服务 sudo systemctl restart docker.service c.查看状态 sudo systemctl status docker -l d.查看服务 sudo docker info 为什么配置这个呢？原因是docker下载镜像速度慢，需要配置国内镜像加速。 Docker可以运行在MAC、Windows、CentOS、UBUNTU等操作系统上，本课程基于CentOS7安装Docker 官网：https://www.docker.com #1、yum包更新到最新 yum update #2、安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 #3、设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo #4、安装docker，出现输入的界面都按 y yum install -y docker-ce #5、查看docker版本，验证是否验证成功 docker -v 2.1docker命令1.进程相关命令 启动docker服务: systemctl start docker 停止docker服务: systemctl stop docker 重启docker服务: systemctl restart docker 查看docker服务状态: systemctl status docker 设置开机启动docker服务: systemctl enable docker 2.镜像相关命令 镜像命令包括如下内容：查看镜像、搜索镜像、拉取镜像、删除镜像 查看镜像:查看本地所有的镜像 docker images docker images –q #查看所用镜像的id 搜索镜像:从网络中查找需要的镜像 docker search 镜像名称 docker search redis #查找redis镜像 拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为名称:版本号，如果版本号不指定则是最新的版本lastest。 如果不知道镜像版本，可以去dockerhub搜索对应镜像查看。 docker pull 镜像名称 docker pull redis #下载最新版本redis docker pull redis:5.0 #下载5.0版本redis 删除镜像:删除本地镜像 docker rmi 镜像id #删除指定本地镜像 docker images -q #查看所有的镜像列表 dockerrmi `docker images -q` #删除所有本地镜像 3.容器相关命令 查看容器、创建容器、进入容器、启动容器、停止容器、删除容器、查看容器信息 查看容器 docker ps #查看正在运行的容器 docker ps –a #查看所有容器 创建并启动容器 docker run 参数 参数说明： -i：保持容器运行。通常与-t同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 -t：为容器重新分配一个伪输入终端，通常与-i同时使用。 -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用dockerexec进入容器。退出后，容器不会关闭。 -it创建的容器一般称为交互式容器，-id创建的容器一般称为守护式容器 –name：为创建的容器命名。 docker run -it --name=c1 centos:7 /bin/bash #创建交互式容器 docker run -id --name=c2 centos:7 #创建守护式容器 注意：交互式容器，exit后容器自动关闭，守护式容器会在后台执行 进入容器 docker exec -it c2 /bin/bash #进入容器 停止容器 docker stop 容器名称 启动容器 dockerstart容器名称 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除 docker rm 容器名称 查看容器信息 docker inspect 容器名称 4.Docker容器的数据卷 …. 3.Docker应用部署3.1MySQL部署 分析 容器内的网络服务和外部机器不能直接通信 外部机器和宿主机可以直接通信宿主机和容器可以直接通信 当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的端口，从而间接访问容器的服务。 这种操作称为：端口映射 1.搜索mysql镜像 docker search mysql 2.拉取mysql镜像 docker pull mysql:5.6 3.创建容器，设置端口映射、目录映射 #在/root目录下创建mysql目录用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ -p 3307:3306 \\ --name=c_mysql \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ mysql:5.6 参数说明： -p 3307:3306：将容器的3306端口映射到宿主机的3307端口。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的conf/my.cnf挂载到容器的 /etc/mysql/my.cnf 。配置目录 -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs。日志目录 -v $PWD/data:/var/lib/mysql：将主机当前目录下的data目录挂载到容器的/var/lib/mysql。数据目录 -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码。 4.进入容器，操作 docker exec -it c_mysql /bin/bash mysql -u root -p123456 show databases; create database db1; 3.2.Tomcat部署 1.搜索tomcat镜像 docker search tomcat 2.拉取tomcat镜像 docker pull tomcat 3.创建容器，设置端口映射、目录映射 # 在/root目录下创建tomcat目录用于存储tomcat数据信息 mkdir ~/tomcat 执行下面的命令： docker run -id --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD:/usr/local/tomcat/webapps：将主机中当前目录挂载到容器的webapps 4.使用外部机器访问tomcat 3.3.Nginx部署 1.搜索nginx镜像 docker search nginx 2.拉取nginx镜像 docker pull nginx 3.创建容器，设置端口映射、目录映射 # 在root目录下创建nginx目录用于存储nginx数据信息 mkdir ~/nginx cd ~/nginx mkdir conf cd conf #在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容 vim nginx.conf 执行下面的命令： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events{ worker_connections 1024; } http{ include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr-$remote_user[$time_local]\"$request\"' '$status$body_bytes_sent\"$http_referer\"' '\"$http_user_agent\"\"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 执行下面的命令启动nginx容器： docker run -id --name=c_nginx \\ -p 80:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 3.4.Redis部署 1.搜索redis镜像 docker search redis 2.拉取redis镜像 docker pull redis:5.0 3.创建容器，设置端口映射 docker run -id --name=c_redis -p 6379:6379 redis:5.0 4.使用外部机器连接redis ./redis-cli.exe -h 192.168.220.12 -p 6379 keys * set name keney get name 4.Dockerfile4.1docker镜像原理： 思考： Docker 镜像本质是什么？ Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？ Docker 中一个tomcat镜像为什么有600MB，而一个tomcat安装包只有70多MB？ 操作系统组成部分： 进程调度子系统 进程通信子系统 内存管理子系统 设备管理子系统 文件管理子系统 网络通信子系统 作业控制子系统 Linux文件系统由bootfs和rootfs两部分组成 bootfs：包含bootloader（引导加载程序）和 kernel（内核） rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件 不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等 docker镜像原理 Docker镜像是由特殊的文件系统叠加而成 最底端是 bootfs，并使用宿主机的bootfs 第二层是 root文件系统rootfs,称为base image 然后再往上可以叠加其他的镜像文件 统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的 视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。 当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器 回答问题 1.Docker 镜像本质是什么？ 是一个分层文件系统 2.Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？ Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其 他镜像层 3.Docker 中一个tomcat镜像为什么有600MB，而一个tomcat安装包只有70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外 暴露的tomcat镜像大小600多MB 4.2镜像制作 容器转换镜像 docker commit 容器id 镜像名称:版本号 docker save -o 压缩文件名称 镜像名称:版本号 docker load –i 压缩文件名称 # 创建tomcat镜像 docker run -id --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat # 进入tomcat镜像 docker exec -it c_tomcat /bin/bash #创建a.txt b.txt cd ~ touch a.txt b.txt 执行操作： #容器转镜像 docker commit 28b8d4dc9744 lxs_tomcat:1.0 #压缩镜像 docker save -o lxs_tomcat.tar lxs_tomcat:1.0 #删除原来镜像 docker rmi lxs_tomcat:1.0 #从压缩文件加载镜像 docker load -i lxs_tomcat.tar #产生镜像 docker run -it --name=new_tomcat lxs_tomcat:1.0 /bin/bash #进入查看内容 docker exec -it c_tomcat /bin/bash #可以看到a.txt b.txt存在，而webapps/test不存在 dockerfile 概念 Dockerfile 是一个文本文件 包含了一条条的指令 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了 对于运维人员：在部署时，可以实现应用的无缝移植 参考Dochub网址：https://hub.docker.com ，比如centos和nginx镜像 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于那个image构建 MAINTAINER 作者信息 用 用来标明这个dockerfile谁写的 LABEL 标签 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在 docker image基本信息中可以查看 RUN 容器启动命 令 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”] CMD 容器启动命 令 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来 源于远程服务 ENV 环境变量 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式 ENV name=value ARG 构建参数 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字 的值始终覆盖arg的参数 VOLUME 定义外部可 以挂载的数 据卷 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容 器的时候使用 -v 绑定 格式 VOLUME [“目录”] EXPOSE 暴露端口 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格 式: EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是 绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 USER 指定执行用 户 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候 的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本 身有健康监测机制 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成 之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 STOPSIGNAL 发送信号量 到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚 本的shell 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell 案例一： 自定义centos7镜像。 要求： 默认登录路径为 /usr 可以使用vim 实现步骤 定义父镜像：FROM centos:7 定义作者信息：MAINTAINER lxs lxs@lxs.cn 执行安装vim命令： RUN yum install -y vim 定义默认的工作目录：WORKDIR /usr 定义容器启动执行的命令：CMD /bin/bash 通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 . #具体代码 mkdir ~/docker-files cd ~/docker-files vim centos_dockerfile dockerfile具体内容 FROM centos:7 MAINTAINER lxs &lt;lxs@lxs.cn&gt; RUN yum install -y vim WORKDIR /usr CMD /bin/bash build docker build -f ./centos_dockerfile -t lxs_centos:1 . -f：镜像文件 -t：新镜像名 . 寻址路径 #进入看效果 docker run -it --name=c2 lxs_centos:1 案例二：发布springboot项目 定义父镜像：FROM java:8 定义作者信息：MAINTAINER lxs lxs@163.com 将jar包添加到容器： ADD springboot.jar app.jar 定义容器启动执行的命令：CMD [“java”,”-jar”,”app.jar”] 通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 . FROM java:8 MAINTAINER lxs &lt;lxs@163.com&gt; ADD springboot.jar app.jar CMD [\"java\",\"-jar\",\"app.jar\"] build docker bulid –f ./springboot_dockerfile –t app . 启动容器 docker run -id -p 9000:8080 app 5.服务编排5.1. 概念 微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启 动停止，维护的工作量会很大。来看下我们日常工作： 要从Dockerfile build image 或者去dockerhub拉取image 要创建多个container 要管理这些container（启动停止删除） 通过服务编排可以大量简化上面的工作服务编排：按照一定的业务规则批量管理容器 5.2 Docker Compose Docker Compose是一个编排多容器分布式部署的工具，提供命令集中管理容器化应用的完整开发周期，包括服务 构建，启动和停止。使用步骤： 利用 Dockerfile 定义运行环境镜像 使用 docker-compose.yml 定义组成应用的各服务 运行 docker-compose up 启动应用 安装Docker Compose # Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以 编译好的二进制包方式安装在Linux系统中。 curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`- `uname -m` -o /usr/local/bin/docker-compose # 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose # 查看版本信息 docker-compose -version 卸载Docker Compose # 二进制包方式安装的，删除二进制文件即可 rm /usr/local/bin/docker-compose 编排nginx+springboot 需求：使用nginx反向代理到springboo应用 创建docker-compose目录 mkdir ~/docker-compose cd ~/docker-compose 2.编写 docker-compose.yml 文件 version: '3' services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - \"8080\" 3.创建./nginx/conf.d目录 mkdir -p ./nginx/conf.d 4.在./nginx/conf.d目录下 编写app.conf文件 server { listen 80; access_log off; location / { proxy_pass http://app:8080/hello; } } 5.在~/docker-compose 目录下 使用docker-compose 启动容器 docker-compose up -d # -d表示已守护模式启动 测试访问 http://192.168.220.12/hello 6.Docker私有仓库 Docker官方的Docker hub（https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉 取镜像 到本地，也可以把我们自己的镜像推送上去。但是，有时候我们不希望将自己的镜 像放到公网当中， 那么这时我们就需要搭建自己的私有仓库来存储和管理自己的镜像 6.1. 私有仓库搭建 # 1、拉取私有仓库镜像 docker pull registry # 2、启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry # 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到{\"repositories\":[]} 表示私有仓 库 搭建成功 # 4、修改daemon.json vim /etc/docker/daemon.json # 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自 己私有仓库服务器真实ip {\"insecure-registries\":[\"私有仓库服务器ip:5000\"]} {\"insecure-registries\":[\"192.168.220.12:5000\"]} # 5、重启docker 服务 systemctl restart docker docker start registry 6.2将镜像上传至私有仓库 # 1、标记镜像为私有仓库的镜像 docker tag centos:7 192.168.220.12:5000/centos:7 # 2、上传标记的镜像 docker push 192.168.220.12:5000/centos:7 从私有仓库拉取镜像 #拉取镜像 docker pull 192.168.220.12:5000/centos:7 附件参考：https://www.cnblogs.com/yakniu/p/16329611.html 参考：服务端口占用情况：https://www.leixue.com/qa/how-does-centos-check-port-occupancy 参考mysql数据库问题： 【MySql】Navicat 连接数据库出现1251 - Client does not support authentication protocol …… 问题的解决方法： https://blog.csdn.net/pengfeng111833/article/details/124399404 https://blog.csdn.net/piupiu78/article/details/122468163","categories":[{"name":"linux","slug":"linux","permalink":"http://www.nnxx.me/categories/linux/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://www.nnxx.me/tags/%E5%90%8E%E7%AB%AF/"},{"name":"linux","slug":"linux","permalink":"http://www.nnxx.me/tags/linux/"}],"author":"nxg"},{"title":"Git多账号配置","slug":"gitMore","date":"2022-10-31T00:00:00.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/e238cc11.html","link":"","permalink":"http://www.nnxx.me/posts/e238cc11.html","excerpt":"","text":"一、背景​ 在同一台电脑上有时候需要使用多个GitHub、gitee、gitlab账号，或者说你有多个账号，不想来回生成公钥，那么这就需要使用到git配置多账户了。 二、准备环境：window 10、git 在使用之前你需要安装git，对于git安装也是点击下一步下一步就可以安装完成，在此也需要对git命令有一定的了解。 前提条件：需要C:\\Users\\nxg.ssh目录（文件夹）下，打开git bash 如下图所示： 打开之后使用这个界面： 注意：这路径C:\\Users\\nxg.ssh对于有一定基础的根据上图是能看明白，就不再赘述了。 ​ 为什么先执行这一步呢？原因是这样的在你创建config文件，生成密钥时都需要创建在这个**.ssh**目录（文件夹）下。如果你在其他目录下打开，那你就需要考虑创建文件时的路径问题了。为了方便明了，就使用上述方法操作，省时省力。 三、配置3.1 创建config文件在C:\\Users\\nxg.ssh目录（文件夹）下创建config文件，并且配置ssh key的路由策略。 创建config文件： touch config 在config文件中配置 # GitHub Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa User git # Github2 Host github2 HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github2 User git # gitee Host gitee.com #自己的码云地址 HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee User git 效果如图所示： “#” 表示注释Host 后面是名称，可以随便写，相当于起了一个别名 每一个Host就代表一个仓库，仓库参数另起一行，前有4个空格HostName ： 真正连接的服务器地址 ssh的host，SSH地址“git@”后面到冒号前面的内容 User：自定义的用户名，一般使用“git”PreferredAuthentications： 指定优先使用哪种方式验证，支持密码和秘钥验证方式 。使用“publickey”即可，git仓库均为这种形式 权限认证–可设为publickey,password publickey,keyboard-interactive等IdentityFile：指定本次连接使用的密钥文件。 该host后台配置的公钥对应的私钥地址的绝对路径Port ： SSH默认端口号为22，某些私有部署的git仓库会更换端口号 3.2 全局配置以github为例： # global全局配置,这里使用全局配置 # 设置用户名： git config --global user.name 'abc' # 设置邮箱： git config --global user.email \"123456@qq.com\" #秘钥添加到本地，即生成密钥 ssh-keygen -t rsa -C \"123456@qq.com\" # 同理gitee账号也是这么操作的。 注：这里的abc是GitHub用户名 ，123456@qq.com这里是你绑定GitHub上的邮箱 如下图效果： 配置gitee效果如下图所示： 注意：生成密钥文件需要与这里保持一致 测试是否连接成功测试GitHub是否连接成功： ssh -T git@github2 成功效果： Hi abc! You've successfully authenticated, but GitHub does not provide shell access. 测试Gitee是否连接成功： $ ssh -T git@gitee.com 成功效果： Hi nxg! You've successfully authenticated, but GITEE.COM does not provide shell access. 注意事项： 四、关联github将id_rsa_gitee.pub文件中的内容添加到gitee设置中的SSH公钥中。 将id_rsa_github2.pub文件中的内容添加到github的settings的SSH and GPG keys的SSH公钥中。 注：上面的文件都在 效果如下图所示： 注意在配置多个账号的，方式有多种，可以使用直接修改文件的方式，也可以使用命令的方式 这里使用修改文件的方式 首先需要在这C:\\Users\\nxg路径下，找到**.gitconfig**文件，并打开此文件 注意：别直接双击打开，需要选择打开方式，选文本打开，或者其他编辑工具打开。 .gitconfig文件内容： [user] name = xiaoli email = 121212@qq.com [core] autocrlf = true [http] sslVerify = false [user] name = abc email = 123456@qq.com [core] autocrlf = true [http] sslVerify = false 效果如下图所示： 查看账号列表：git config --global --list 效果如图所示： 添加密钥的方式方式一： ssh-keygen -t rsa -C \"123456@qq.com\" 再执行 id_rsa 方式二： ssh-keygen -t rsa -C \"2011465907@qq.com\" -f ~/.ssh/id_rsa 效果如图所示： ssh-keygen常用参数说明: -t: 密钥类型, 可以选择 dsa | ecdsa | ed25519 | rsa; -f: 密钥目录位置, 默认为当前用户home路径下的.ssh隐藏目录, 也就是~/.ssh/, 同时默认密钥文件名以id_rsa开头. 如果是root用户, 则在/root/.ssh/id_rsa, 若为其他用户, 则在/home/username/.ssh/id_rsa; -C: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议携带; -N: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了. 举例说明: 同时指定目录位置、密码、注释信息, 就不需要输入回车键即可完成创建: 附件git单一账号使用教程","categories":[{"name":"运维","slug":"运维","permalink":"http://www.nnxx.me/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.nnxx.me/tags/git/"}]},{"title":"Git提交本地代码至分支（详细每一步）","slug":"git","date":"2022-09-28T00:00:00.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/de0da321.html","link":"","permalink":"http://www.nnxx.me/posts/de0da321.html","excerpt":"","text":"查看分支A: 查看本地分支使用 git branch命令，如下：git branch*标识的是你当前所在的分支 B: 查看远程分支 命令如下：git branch -r C: 查看所有分支 命令如下：git branch -a 二、本地创建新分支 命令如下：git branch [分支名称] 例如：git branch plateformSuperdog 三、切换到新分支 命令如下：git checkout [分支名称] 例如：git checkout plateformSuperdog 四、创建+切换分支 命令如下：git checkout -b [分支名称] 例如：git checkout -b plateform2 其中：git checkout -b [分支名称]相当于两步 git branch [分支名称] git checkout [分支名称] 五、将新分支推送到github 命令如下：git push origin [分支名称] 六：删除本地分支 命令如下：git branch -d [分支名称] 七、删除github 远方分支 命令如下：git push origin :[branch name] 其中：分支前面：代表删除 例如：git push origin : plateform2 八：git 提交本地代码至新分支 1.切换到新分支 命令如下：git checkout [分支名称] 例如：git checkout plateform2 2.添加本地需要提交的代码 命令如下：git add . 3.提交本地代码 命令如下：git commit -m “修改说明” 4.push到git仓库 命令如下：git push origin [分支名称] 例如：git push origin plateform2 简单总结一下： 拉取仓库（克隆）： git clone [ssh仓库地址] //cd 进入仓库 cd 文件夹名（克隆的文件夹） 将要提交的代码复制到该仓库中（克隆的文件夹中） //创建分支 git branch 分支名称 //提交分支到远程仓库 git push origin 分支名 //切换想要切换的分支， git checkout 分支名 //提交代码到想要提交的分支上 git add ./ git commit -m \"提交了代码\" git push //或者 git push origin 分支名 注意：这也是需要绑定github账号 合并分支https://blog.csdn.net/chenyao1994/article/details/114686758 git合并分支（一看就懂） 假如我们现在在dev分支上，刚开发完项目，执行了下列命令： git add . git commit -m '提交的备注信息' git push -u origin dev 想将dev分支合并到master分支，操作如下： 1、首先切换到master分支上 git checkout master 2、如果是多人开发的话 需要把远程master上的代码pull下来 git pull origin master //如果是自己一个开发就没有必要了，为了保险期间还是pull 3、然后我们把dev分支的代码合并到master上 git merge dev 4、然后查看状态及执行提交命令 git status On branch master Your branch is ahead of 'origin/master' by 12 commits. (use \"git push\" to publish your local commits) nothing to commit, working tree clean //上面的意思就是你有12个commit，需要push到远程master上 &gt; 最后执行下面提交命令 git push origin master 5、其他命令 更新远程分支列表 git remote update origin --prune 查看所有分支 git branch -a 删除远程分支Chapater6 git push origin --delete Chapater6 删除本地分支 Chapater6 git branch -d Chapater6 附件\\GIT开发学习——合并分支的几种方法**https://blog.csdn.net/fenglolo/article/details/125223433","categories":[{"name":"运维","slug":"运维","permalink":"http://www.nnxx.me/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.nnxx.me/tags/git/"}]},{"title":"JavaScript笔记","slug":"JavaScript笔记","date":"2021-03-01T00:00:00.000Z","updated":"2023-04-23T09:04:14.546Z","comments":true,"path":"posts/3274106043.html","link":"","permalink":"http://www.nnxx.me/posts/3274106043.html","excerpt":"","text":"JavaScriptJavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JS的编写的位置1.可以编写到标签的指定属性中 &lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt; &lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt; 2.可以编写到script标签中 &lt;script type=\"text/javascript\"&gt; //编写js代码 &lt;/script&gt; 3.可以将代码编写到外部的js文件中，然后通过标签将其引入 script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的script标签用于编写内部代码 &lt;script type=\"text/javascript\" src=\"文件路径\"&gt;&lt;/script&gt; 输出语句alert(\"要输出的内容\"); 该语句会在浏览器窗口中弹出一个警告框 document.write(\"要输出的内容\"); 该内容将会被写到body标签中，并在页面中显示 console.log(\"要输出的内容\"); 该内容会被写到开发者工具的控制台中 基本的语法js函数声明不需要；分号，但是赋值语句要加；分号 function functionName(arg0,arg1,arg2){ //函数声明 } var functionName=function(arg0,arg1,arg2){ //函数表达式 };(注意分号) 注释 单行注释 //注释内容 多行注释 /* 注释内容 */ JS严格区分大小写 JS中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写 JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 字面量和变量字面量字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN “hello”字面量都是不可以改变的。 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 变量变量可以用来保存字面量，并且可以保存任意的字面量 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述 声明变量 使用var关键字来声明一个变量 var a; 为变量赋值 a = 1; 声明和赋值同时进行 var a = 456; 标识符在JS中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。 比如：变量名、函数名、属性名 规范：1.标识符中可以含有字母、数字、_、$2.标识符不能以数字开头3.标识符不能是JS中的关键字和保留字4.标识符一般采用驼峰命名法xxxYyyZzz 数据类型数据类型指的就是字面量的类型 六种数据类型JS中一共分成六种数据类型 5种基本数据类型+objectString 字符串Number 数值Boolean 布尔值Null 空值Undefined 未定义Object 对象 其中string、number、Boolean、null、undefined为5种基本数据类型，而object属于引用数据类型 typeof运算符检查数据类型 可以使用一个运算符typeof来检查一个变量的类型 语法：typeof 变量 检查字符串时，会返回string 检查数值时会返回number var a = 12; console.log(typeof a); 下面是详细说明各数据类型 1.String 字符串JS中的字符串需要使用引号引起来，双引号或单引号都行在字符串中转义字符的使用 \\ ==&gt; 转义字符 \\' ==&gt; ' \\\" ==&gt; \" \\n ==&gt; 换行 \\t ==&gt; 制表符 \\\\ ==&gt; \\ 使用typeof运算符检查字符串时，会返回”string” var str = \"abc\"; console.log(str); 2.Number 数值JS中所有的整数和浮点数（小数）都是Number类型 数字的最大能表示的值：Number.MAX_VALUE= 1.7976931348623157e+308 数字的最大能表示的值：Number.MIN_VALUE=5e-324 注：1.2e+308是科学计数法表示1.2乘以10的308次方 如果使用Number表示的数值超过了最大值，则会返回一个Infinity Infinity是字面量 特殊的数字：能赋值给变量 Infinity 正无穷 a = Infinity ,能赋值-Infinity 负无穷NaN 非法数字（Not A Number）——–是一个 特殊的数字其他进制的数字的表示：0b 开头表示二进制，但是不是所有的浏览器都支持0 开头表示八进制0x 开头表示十六进制 使用typeof检查一个Number类型的数据时，会返回”number”（包括NaN 和 Infinity） 3.Boolean 布尔值布尔值主要用来进行逻辑判断，布尔值只有两个true 逻辑的真false 逻辑的假使用typeof检查一个布尔值时，会返回”boolean” 4.Null 空值空值专门用来表示为空的对象，Null类型的值只有一个null使用typeof检查一个Null类型的值时会返回”object” 5.Undefined 未定义如果声明一个变量，但是并不给变量赋值，此时变量的值就是undefined该类型的值只有一个 undefined使用typeof检查一个Undefined类型的值时，会返回”undefined” 引用数据类型Object 对象 类型转换类型转换主要指，将其他的数据类型转换为string、number、Boolean 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean 转换为String强制 类型转换指将一个数据类型强制转换为其他·的数据类型 方式一（强制类型转换）：调用被转换数据的toString()方法 调用xxx的yyy()方法，就是xxx.yyy() eg： var a = 123; a = a.toString(); //调用a的toString()方法 该方法不会影响到原变量，它会将转换的结果返回 但注意：**这个方法不适用于null和undefined**由于这两个类型的数据中没有方法，所以调用toString()时会报错 eg var a=233; a = a.toString(); a = null; //a = a.toString(); //会报错 a = undefine; //a = a.toString(); //会报错 console.log(typeof a); 方式二（强制类型转换）：调用String()函数 调用String()函数，并将被转换的数据作为参数传递给函数 使用String()函数做强制转换时，对于Number·和·Boolean实际上就是调用toString()方法 但是对于null和undefined，就不会调用toString()方法 ​ 它会将null 直接转换为 “null” ​ 将会undefined 直接转换为“undefined” 例子： var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined” 方式三（隐式的类型转换）:为任意的数据类型 +””例子： var a = true; a = a + \"\"; 原理：和String()函数一样 转换为Number方式一（强制类型转换）：调用Number()函数例子： var s = \"123\"; s = Number(s); 转换的情况： 字符串 –&gt; 数字如果字符串是一个合法的数字(纯数字），则直接转换为对应的数字如果字符串是一个非法的数字（非数字的内容），则转换为NaN如果是一个空串或纯空格的字符串（全是空格的字符），则转换为0 布尔值 –&gt; 数字true转换为1false转换为0 空值 –&gt; 数字null转换为0 未定义 &gt; 数字undefined 转换为NaN 方式二（强制类型转换）：调用parseInt()或parseFloat()这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt()可以将一个字符串中的有效的整数位提取出来，并转换为Number例子： //parse为解析，int为整型 //调用parseInt()函数将a转换为Number var a = \"123.456px\"; a = parseInt(a); //123 如果需要可以在parseInt()中指定一个第二个参数，来指定进制parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number例子： //parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数 var a = \"123.456px\"; a = parseFloat(a); //123.456 如果对非String使用parseInt()或parseFloat(),它会先将其转换为String，然后再操作 eg： a = true; a = parseInt(a); console.log(typeof a);//检查类型就字符串 console.log(a);//输出的是NaN 方式三（隐式的类型转换）：使用一元的+来进行隐式的类型转换例子： var a = \"123\"; a = +a; 原理：和Number()函数一样 其他进制的数字在js中，如果需要表示16进制的数字，则需要以0x开头 ​ 如果需要表示8进制的数字，则需要以0开头 ​ 如果需要表示2进制的数字，则需要以0b开头 ​ 但是不是所有的浏览器都支持 var a = 23; //十六进制 a = 0x10; a = 0xff; a = 0xCafe; //八进制 a = 070; //二进制 // a = 0b10; //像“070“这种字符串，有些浏览器会当成8进制解析，有些会当成10进制解析 a = \"070\"; //可以在parseInt()中传递一个第二个参数，来指定数字的进制 //parseInt(参数，指定进制) a = parseInt(a,10); console.log(typeof a); console.log(a); 转换为布尔值方式一（强制类型转换）：使用Boolean()函数例子： var s = \"false\"; s = Boolean(s); //true 转换的情况字符串 —&gt; 布尔除了空串其余全是true 数值 —&gt; 布尔除了0和NaN其余的全是true null、undefined —&gt; 布尔都是false 对象 —&gt; 布尔都是true 方式二（隐式类型转换）：为任意的数据类型做两次非运算，即可将其转换为布尔值例子： var a = \"hello\"; a = !!a; //true 基础语法运算符运算符也称为操作符通过运算符可以对一个或多个值进行运算或操作 typeof运算符用来检查（获取）一个变量的数据类型语法：typeof 变量它会返回一个用于描述类型的字符串作为结果 算数运算符+ 对两个值进行加法运算并返回结果- 对两个值进行减法运算并返回结果* 对两个值进行乘法运算并返回结果/ 对两个值进行除法运算并返回结果% 对两个值进行取余运算并返回结果 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。任何值和字符串做加法，都会先转换为字符串，然后再拼串 var result = 123; result = 1+2+\"3;//33 result = \"1\"+2+3;//123 rsult = 1+\"12\";//会先转换为字符串，然后再拼串 console.log(result);//返回的值为112 一元运算符一元运算符只需要一个操作数 一元的+就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字例子： var a = true; a = +a; 一元的-就是负号，可以对一个数字进行符号位取反例子： var a = 10; a = a; 自增自增可以使变量在原值的基础上自增1自增使用 ++自增可以使用 前++（++a）后++(a++)无论是++a 还是 a++都会立即使原变量自增1不同的是++a 和 a++的值是不同的，++a的值是变量的新值（自增后的值）a++的值是变量的原值（自增前的值） var d = 10; //第一次d++，是在10的基础上自增 console.log(d++);//11 //第二次d++，是在11的基础上自增 d++;//10 自减自减可以使变量在原值的基础上自减1自减使用 –自减可以使用 前–（–a）后–(a–)无论是–a 还是 a– 都会立即使原变量自减1不同的是–a- 和 a–的值是不同的，–a的值是变量的新值（自减后的值）a–的值是变量的原值（自减前的值） 逻辑运算符!非运算可以对一个布尔值进行取反，true变false false边true当对非布尔值使用!时，会先将其转换为布尔值然后再取反我们可以利用!来将其他的数据类型转换为布尔值 &amp;&amp;&amp;&amp;可以对符号两侧的值进行与运算只有两端的值都为true时，才会返回true。只要有一个false就会返回false。与是一个短路的与，如果第一个值是false，则不再检查第二个值对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值规则：1.如果第一个值为false，则返回第一个值2.如果第一个值为true，则返回第二个值 ||||可以对符号两侧的值进行或运算只有两端都是false时，才会返回false。只要有一个true，就会返回true。或是一个短路的或，如果第一个值是true，则不再检查第二个值对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值规则：1.如果第一个值为true，则返回第一个值2.如果第一个值为false，则返回第二个值 赋值运算符=可以将符号右侧的值赋值给左侧变量+= a += 5 相当于 a = a+5 var str = \"hello\"; str += \"world\"; -= a -= 5 相当于 a = a-5 *= a *= 5 相当于 a = a*5 /= a /= 5 相当于 a = a/5 %= a %= 5 相当于 a = a%5 关系运算符关系运算符用来比较两个值之间的大小关系的&gt;&gt;=&lt;&lt;=关系运算符的规则和数学中一致，用来比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。如果比较的两个值是非数值，会将其转换为Number然后再比较。如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。 相等运算符相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true，null == undifined !=不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false不等也会做自动的类型转换。 ===全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，如果两个值的类型不同，则直接返回false !==不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 特殊的值：null和undefined由于undefined衍生自null，所以null == undefined 会返回true。但是 null === undefined 会返回false。NaNNaN不与任何值相等，报告它自身 NaN == NaN //false 判断一个值是否是NaN使用isNaN()函数 三元运算符：?:语法：条件表达式?语句1:语句2;执行流程：先对条件表达式求值判断，如果判断结果为true，则执行语句1，并返回执行结果如果判断结果为false，则执行语句2，并返回执行结果 优先级：和数学中一样，JS中的运算符也是具有优先级的，比如 先乘除 后加减 先与 后或具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，优先级越高的越优先计算，优先级相同的，从左往右计算。优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 流程控制语句程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 条件分支语句条件判断语句也称为if语句语法一： if(条件表达式){ 语句... } 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句... }else{ 语句... } 执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 1.条件分支语句switch语句语法: switch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程：switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较，如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。如果所有的case判断结果都为false，则从default处开始执行代码。 循环语句通过循环语句可以反复执行某些语句多次while循环语法： while(条件表达式){ 语句... } 执行流程：while语句在执行时，会先对条件表达式进行求值判断，如果判断结果为false，则终止循环如果判断结果为true，则执行循环体循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环语法: do{ 语句... }while(条件表达式) 执行流程do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，如果判断判断结果为false，则终止循环。如果判断结果为true，则继续执行循环体，依此类推 和while的区别：while：先判断后执行do…while: 先执行后判断do…while可以确保循环体至少执行一次。 for循环语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } 执行流程：首先执行①初始化表达式，初始化一个变量，然后对②条件表达式进行求值判断，如果为false则终止循环如果判断结果为true，则执行③循环体循环体执行完毕，执行④更新表达式，对变量进行更新。更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } 对象（Object）对象是JS中的引用数据类型对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性使用typeof检查一个对象时，会返回object 对象的分类：1.内建对象- 由ES标准中定义的对象，在任何的ES的实现中都可以使用- 比如：Math String Number Boolean Function Object…. 2.宿主对象- 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象- 比如 BOM DOM 3.自定义对象 - 由开发人员自己创建的对象 创建对象方式一： var obj = new Object(); 方式二： var obj = {}; 向对象中添加属性语法：对象.属性名 = 属性值;对象[“属性名”] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。 读取对象中的属性语法：对象.属性名对象[“属性名”] //“属性名”可以使字符串常量，也可以是字符串变量如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性语法： delete 对象.属性名 delete 对象[\"属性名\"] 遍历使用in检查对象中是否含有指定属性语法：”属性名” in 对象如果在对象中含有该属性，则返回true如果没有则返回false 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). var obj = {'0':'a','1':'b','2':'c'}; for(var i in obj) { console.log(i,\":\",obj[i]); } 使用对象字面量，在创建对象时直接向对象中添加属性语法： var obj = { 属性名:属性值, 属性名:属性值, 属性名:属性值, 属性名:属性值 } 基本数据类型和引用数据类型基本数据类型String Number Boolean Null Undefined引用数据类型Object基本数据类型的数据，变量是直接保存的它的值。变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。引用数据类型的数据，变量是保存的对象的引用（内存地址）。如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型比较的是地址，地址相同才相同 函数（Function）函数也是一个对象，也具有普通对象的功能（能有属性）函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码使用typeof检查一个函数时会返回function创建函数函数声明 function 函数名([形参1,形参2...形参N]){ 语句... } 函数表达式 var 函数名 = function([形参1,形参2...形参N]){ 语句... }; 调用函数语法：函数对象([实参1,实参2…实参N]);fun() sum() alert() Number() parseInt()当我们调用函数时，函数中封装的代码会按照编写的顺序执行 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数立即执行函数往往只会执行一次 (function(a,b){ console.log(\"a = \"+a); console.log(\"b = \"+b); })(123,456); 遍历对象 for(var v in obj){ document.write(\"property：name =\"+v+\"value=\"+obj[v]+\"&lt;br/&gt;\" ); } 形参和实参形参：形式参数定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。 实参：实际参数调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。如果实参的数量大于形参，多余实参将不会赋值，如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined 返回值，就是函数执行的结果。使用return 来设置函数的返回值。语法：return 值;该值就会成为函数的返回值，可以通过一个变量来接收返回值return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。如果return后不跟值，或者是不写return则函数默认返回undefined。break、continue和returnbreak退出循环continue跳过当次循环return退出函数 参数，函数的实参也可以是任意的数据类型。 方法（method）可以将一个函数设置为一个对象的属性，当一个对象的属性是一个函数时，我们称这个函数是该对象的方法。对象.方法名();函数名() 函数的属性和方法call()apply()这两个方法都是函数对象的方法需要通过函数对象来调用通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递argumentsarguments和this类似，都是函数中的隐含的参数arguments是一个类数组元素，它用来封装函数执行过程中的实参所以即使不定义形参，也可以通过arguments来使用实参arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象）this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象1.以函数的形式调用时，this是window2.以方法的形式调用时，this是调用方法的对象3.以构造函数的形式调用时，this是新建的那个对象4.使用call和apply调用时，this是指定的那个对象5.在全局作用域中this代表window 作用域作用域简单来说就是一个变量的作用范围。在JS中作用域分成两种： 1.全局作用域 直接在script标签中编写的代码都运行在全局作用域中全局作用域在打开页面时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。在全局作用域中创建的变量都会作为window对象的属性保存在全局作用域中创建的函数都会作为window对象的方法保存在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。尽量不要在全局中创建变量 2.函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。函数作用域在函数执行时创建，在函数执行结束时销毁。在函数作用域中创建的变量，不能在全局中访问。当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会 变量的声明提前在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量 函数的声明提前在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 this（上下文对象）我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 指向当前对象 this的不同的情况：1.以函数的形式调用时，this是window2.以方法的形式调用时，this就是调用方法的对象3.以构造函数的形式调用时，this就是新创建的对象 4.构造函数构造函数是专门用来创建对象的函数一个构造函数我们也可以称为一个类通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例通过同一个构造函数创建的对象，我们称为一类对象构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数如果使用new来调用，则它就是一个构造函数 例子： function Person(name , age , gender){ this.name = name; this.age = age; this.gender = gender; this.sayName = function(){ alert(this.name); }; } 构造函数的执行流程：1.创建一个新的对象2.将新的对象作为函数的上下文对象（this）3.执行函数中的代码4.将新建的对象返回 instanceof 用来检查一个对象是否是一个类的实例语法：对象 instanceof 构造函数如果该对象时构造函数的实例，则返回true，否则返回falseObject是所有对象的祖先，所以任何对象和Object做instanceof都会返回true 枚举对象中的属性for…in语法： for(var 属性名 in 对象){ } for…in语句的循环体会执行多次，对象中有几个属性就会执行几次，每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性 原型（prototype）创建一个函数以后，解析器都会默认在函数中添加一个数prototypeprototype属性指向的是一个对象，这个对象我们称为原型对象。当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。 这个隐含的属性可以通过对象.__proto__来访问。 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。我们可以将对象中共有的属性和方法统一添加到原型对象中，这样我们只需要添加一次，就可以使所有的对象都可以使用。当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，如果在自身中找到了，则直接使用。如果没有找到，则去原型对象中寻找，如果找到了则使用，如果没有找到，则去原型的原型中寻找，\\依此类推。直到找到Object的原型为止，Object的原型的原型为null，如果依然没有找到则返回undefined**hasOwnProperty()**这个方法可以用来检查**对象自身中**是否含有某个属性语法：对象.hasOwnProperty(“属性名”) toString方法当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值 如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法 //修改Person原型的toString Person.prototype.toString = function(){ return \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\"; }; 垃圾回收（GC）就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作我们需要做的只是要将不再使用的对象设置null即可 数组（Array）数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高数组中保存的内容我们称为元素数组使用索引（index）来操作元素索引指由0开始的整数 数组的操作：创建数组 var arr = new Array(); var arr = []; 向数组中添加元素语法；数组对象[索引] = 值; arr[0] = 123; arr[1] = \"hello\"; 创建数组时直接添加元素语法： var arr = [元素1,元素2....元素N]; 例子： var arr = [123,\"hello\",true,null]; 获取和修改数组的长度使用length属性来操作数组的长度获取长度：数组.lengthlength获取到的是数组的最大索引+1对于连续的数组，length获取到的就是数组中元素的个数修改数组的长度数组.length = 新长度如果修改后的length大于原长度，则多出的部分会空出来如果修改后的length小于原长度，则原数组中多出的元素会被删除向数组的最后添加元素数组[数组.length] = 值; 数组的方法 functionName function usage push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 语法：数组.push(元素1,元素2,元素N)pop() pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的开头添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的开头的一个元素，并返回被删除的元素 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 slice(sart,[end])可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 1.截取开始位置的索引（包括开始位置） 2.截取结束位置的索引（不包括结束位置） 第二个参数可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数 splice()可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 参数： 1.删除开始位置的索引 2.删除的个数 3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 join([splitor])可以将一个数组转换为一个字符串参数：需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素如果不指定连接符则默认使用, sort()可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序调用以后，会直接修改原数组。可以自己指定排序的规则，需要一个回调函数作为参数： 我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参,浏览器将会分别使用数组中的元素作为实参去调用回调函数使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边 浏览器会根据回调函数的返回值来决定元素的顺序，如果返回一个大于0的值，则元素会交换位置如果返回一个小于0的值，则元素位置不变如果返回一个0，则认为两个元素相等，也不交换位置 如果需要升序排列，则返回 a-b如果需要降序排列，则返回b-a function(a,b){ //升序排列 //return a-b; //降序排列 return b-a; } 遍历数组遍历数组就是将数组中元素都获取到一般情况我们都是使用for循环来遍历数组 for(var i=0 ; i&lt;数组.length ; i++){ //数组[i] } 使用forEach()方法来遍历数组（不兼容IE8） 数组.forEach(function(value , index , obj){ }); forEach()方法需要一个回调函数作为参数，数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来，我们可以定义形参来获取这些信息。value:正在遍历的元素index:正在遍历元素的索引obj:被遍历对象 常用类和方法包装类在JS中为我们提供了三个包装类：String() Boolean() Number()通过这三个包装类可以创建基本数据类型的对象例子： var num = new Number(2); var str = new String(\"hello\"); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。 当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁。 Date日期的对象，在JS中通过Date对象来表示一个时间创建对象创建一个当前的时间对象 var d = new Date(); 创建一个指定的时间对象 var d = new Date(\"月/日/年 时:分:秒\"); 方法： name getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 MathMath属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法我们可以直接使用它来进行数学运算相关的操作方法：Math.PI常量，圆周率Math.abs()绝对值运算Math.ceil()向上取整Math.floor()向下取整Math.round()四舍五入取整Math.random()生成一个01之间的随机数生成一个xy之间的随机数Math.round(Math.random()*(y-x)+x);Math.pow(x,y)求x的y次幂Math.sqrt()对一个数进行开方Math.max()求多个数中最大值Math.min()求多个数中的最小值 字符串的相关的方法使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 **String.prototype.padEnd(maxLength, fillString=’’)**来填充字符串； length获取字符串的长度charAt()根据索引获取指定的字符charCodeAt()根据索引获取指定的字符编码String.fromCharCode()根据字符编码获取字符indexOf()lastIndexOf()从一个字符串中检索指定内容需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。可以指定一个第二个参数，来表示开始查找的位置indexOf()是从前向后找lastIndexOf()是从后向前找slice(start,[end])可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量参数：第一个：截取开始的位置（包括开始）第二个：截取结束的位置（不包括结束）可以省略第二个参数，如果省略则一直截取到最后可以传负数，如果是负数则从后往前数substr()和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring()和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置toLowerCase()将字符串转换为小写并返回toUpperCase()将字符串转换为大写并返回 正则表达相关方法split()可以根据指定内容将一个字符串拆分为一个数组参数：需要一个字符串作为参数，将会根据字符串去拆分数组可以接收一个正则表达式，此时会根据正则表达式去拆分数组 match()可以根据正则表达式，从一个字符串中将符合条件的内容提取出来默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容可以为一个正则表达式设置多个匹配模式，且顺序无所谓match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 replace()可以将字符串中指定内容替换为新的内容参数：1.被替换的内容，可以接受一个正则表达式作为参数2.新的内容 空串则为删除””默认只会替换第一个 search()可以搜索字符串中是否含有指定内容如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串serach()只会查找第一个，即使设置全局匹配也没用 正则表达式正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。创建正则表达式var reg = new RegExp(“正则”,”匹配模式”); 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 var reg = /正则表达式/匹配模式 （匹配模式可以多个一起写：/gi） 语法：匹配模式：i:忽略大小写（ignore）g:全局匹配模式（默认为1次）设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求 正则语法| 或[] 或[^ ] 除了 **[x-y] x的ascii到y的ascii码之间的值** [a-z] 小写字母 （也可以[e-i])[A-Z] 大写字母[A-z] 任意字母,但是还包括了其他ASCII在此之中的[0-9] 任意数字 元符号 检查一个字符串中是否含有 .. 表示任意字符在正则表达式中使用\\作为转义字符. 来表示.\\ 表示\\ \\w任意字母、数字、_ [A-z0-9_]\\W除了字母、数字、_ [ ^A-z0-9_]\\d任意的数字 [0-9]\\D除了数字 [ ^0-9]\\s空格\\S除了空格\\b单词边界\\B除了单词边界 量词通过量词可以设置一个内容出现的次数量词只对它前边的一个内容起作用{n} 正好出现n次{m,n} 出现mn次{m,} m次以上 +至少一个，相当于{1,}*个或多个，相当于{0,}? 0个或1个，相当于{0,1} 边界表达式（不要在java中用，javaScript中用）^:正则开始$:正则结束 ：注意结束前一个才是结束匹配 reg = /^a/; reg = /b$/; 方法：test()可以用来检查一个字符串是否符合正则表达式如果符合返回true，否则返回false例子 去掉两端的空格: var s = \" f afa \"; s = s.replace(/^\\s*|\\s*$/g,\"\"); DOMDocument Object Model文档对象模型，通过DOM可以来任意来修改网页中各个内容文档文档指的是网页，一个网页就是一个文档对象对象指将网页中的每一个节点都转换为对象转换完对象以后，就可以以一种纯面向对象的形式来操作网页了模型模型用来表示节点和节点之间的关系，方便操作页面节点（Node）节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点虽然都是节点，但是节点的类型却是不同的常用的节点文档节点 （Document），代表整个网页元素节点（Element），代表网页中的标签属性节点（Attribute），代表标签中的属性文本节点（Text），代表网页中的文本内容 DOM操作DOM查询在网页中浏览器已经为我们提供了document对象，它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。document查询方法：根据元素的id属性查询一个元素节点对象：document.getElementById(“id属性值”);根据元素的name属性值查询一组元素节点对象:document.getElementsByName(“name属性值”);根据标签名来查询一组元素节点对象：document.getElementsByTagName(“标签名”); 元素的属性：读取元素的属性：语法：元素.属性名例子：ele.nameele.idele.valueele.className注意：class属性不能采用这种方式，读取class属性时需要使用 元素.className 修改元素的属性：语法：元素.属性名 = 属性值 innerHTML使用该属性可以获取或设置元素内部的HTML代码 事件（Event）事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。我们可以为事件来绑定回调函数来响应事件。绑定事件的方式：1.可以在标签的事件属性中设置相应的JS代码例子： &lt;button onclick=\"js代码。。。\"&gt;按钮&lt;/button&gt; 2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件例子： &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; &lt;/script&gt; 文档的加载浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，此时将会无法正常获取到DOM对象，导致DOM操作失败。解决方式一：可以将js代码编写到body的下边 &lt;body&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; &lt;/script&gt; &lt;/body&gt; 解决方式二：将js代码编写到window.onload = function(){}中window.onload 对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了 &lt;script&gt; window.onload = function(){ var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; }; &lt;/script&gt; DOM查询通过具体的元素节点来查询元素.getElementsByTagName()通过标签名查询当前元素的指定后代元素 子节点包括便签元素中的文本，子元素自包含标签元素 元素.childNodes获取当前元素的所有子节点会获取到空白的文本子节点 childNodes属性会获取包括文本节点在呢的所有节点根据DOM标签标签间空白也会当成文本节点注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，所以该属性在IE8中会返回4个子元素而其他浏览器是9个 元素.children获取当前元素的所有子元素 元素.firstChild获取当前元素的第一个子节点，会获取到空白的文本子节点 元素.lastChild获取当前元素的最后一个子节点 元素.parentNode获取当前元素的父元素 元素.previousSibling获取当前元素的前一个兄弟节点 previousElementSibling获取前一个兄弟元素，IE8及以下不支持 元素.nextSibling获取当前元素的后一个兄弟节点 firstElementChild获取当前元素的第一个子元素firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用 innerHTML和innerText这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性两个属性作用类似，都可以获取到标签内部的内容，不同是innerHTML会获取到html标签，而innerText会自动去除标签如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容 h1中的文本内容 元素.firstChild.nodeValue document对象的其他的属性和方法document.all获取页面中的所有元素，相当于document.getElementsByTagName(“*”); document.documentElement获取页面中html根元素 document.body获取页面中的body元素 document.getElementsByClassName()根据元素的class属性值查询一组元素节点对象这个方法不支持IE8及以下的浏览器 document.querySelector()根据CSS选择器去页面中查询一个元素如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll()根据CSS选择器去页面中查询一组元素会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 DOM修改document.createElement(“TagName”)可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回document.createTextNode(“textContent”)可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点)向父节点中添加指定的子节点父节点.insertBefore(新节点,旧节点)将一个新的节点插入到旧节点的前边父节点.replaceChild(新节点,旧节点)使用一个新的节点去替换旧节点 父节点.removeChild(子节点)删除指定的子节点推荐方式：子节点.parentNode.removeChild(子节点) 以上方法，实际就是改变了相应元素（标签）的innerHTML的值。 myClick(\"btn07\",function(){ //向city中添加广州 var city = document.getElementById(\"city\"); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += \"&lt;li&gt;广州&lt;/li&gt;\"; //创建一个li var li = document.createElement(\"li\"); //向li中设置文本 li.innerHTML = \"广州\"; //将li添加到city中 city.appendChild(li); }); DOM对CSS的操作读取和修改内联样式使用style属性来操作元素的内联样式读取内联样式：语法：元素.style.样式名例子：元素.style.width元素.style.height注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写比如：backgroundcolor &gt; backgroundColorborderwidth &gt; borderWidth修改内联样式：语法：元素.style.样式名 = 样式值通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改的样式，往往会立即生效，但是如果样式中设置了!important，则内联样式将不会生效。 读取元素的当前样式正常浏览器使用getComputedStyle()这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式参数：1.要获取样式的元素2.可以传递一个伪元素，一般传null例子：获取元素的宽度getComputedStyle(box , null)[“width”];通过该方法读取到样式都是只读的不能修改 IE8使用currentStyle语法：元素.currentStyle.样式名例子：box.currentStyle[“width”]通过这个属性读取到的样式是只读的不能修改 实现兼容性 //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 /* * 定义一个函数，用来获取指定元素的当前的样式 * 参数： * obj 要获取样式的元素 * name 要获取的样式名 */ function getStyle(obj , name){ //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 if(window.getComputedStyle){ //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj , null)[name]; }else{ //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; } //return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name]; } 其他的样式相关的属性注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角 clientHeight元素的可见高度，包括元素的内容区和内边距的高度clientWidth元素的可见宽度，包括元素的内容区和内边距的宽度offsetHeight整个元素的高度，包括内容区、内边距、边框offfsetWidth整个元素的宽度，包括内容区、内边距、边框offsetParent当前元素的定位父元素离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回bodyoffsetLeftoffsetTop当前元素和定位父元素之间的偏移量offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeightscrollWidth获取元素滚动区域的高度和宽度 scrollTopscrollLeft获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底垂直滚动条scrollHeight -scrollTop = clientHeight 水平滚动scrollWidth -scrollLeft = clientWidth 事件（Event）事件对象当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 例子： 元素.事件 = function(event){ event = event || window.event; }; 元素.事件 = function(e){ e = e || event; }; 获取到鼠标的坐标clientX和clientY用于获取鼠标在当前的可见窗口的坐标div的偏移量，是相对于整个页面的 pageX和pageY 可以获取鼠标相对于当前页面的坐标但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var left = event.clientX;var top = event.clientY; 事件的冒泡（Bubble）事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消可以将事件对象的cancelBubble设置为true，即可取消冒泡例子： 元素.事件 = function(event){ event = event || window.event; event.cancelBubble = true; }; 事件的委派指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的我们可以尝试将其绑定给元素的共同的祖先元素 target : event中的target表示的触发事件的对象 事件的绑定addEventListener()通过这个方法也可以为元素绑定响应函数参数：1.事件的字符串，不要on2.回调函数，当事件触发时该函数会被调用3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行 这个方法不支持IE8及以下的浏览器 btn01.addEventListener(\"click\",function(){ alert(1); },false); btn01.addEventListener(\"click\",function(){ alert(2); },false); attachEvent() 在IE8中可以使用attachEvent()来绑定事件参数：1.事件的字符串，要on2.回调函数 这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是后绑定先执行，执行顺序和addEventListener()相反 btn01.attachEvent(\"onclick\",function(){ alert(1); }); btn01.attachEvent(\"onclick\",function(){ alert(2); }); //定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function bind(obj , eventStr , callback){ if(obj.addEventListener){ //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); }else{ /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function(){ //在匿名函数中调用回调函数 callback.call(obj); }); } } 事件的传播关于事件的传播网景公司和微软公司有不同的理解微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素W3C综合了两个公司的方案，将事件传播分成了三个阶段1.捕获阶段在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件2.目标阶段事件捕获到目标元素，捕获结束开始在目标元素上触发事件3.冒泡阶段事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8及以下的浏览器中没有捕获阶段 常用事件鼠标事件拖拽事件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1{ width: 100px; height: 100px; background-color: red; position: absolute; } #box2{ width: 100px; height: 100px; background-color: yellow; position: absolute; left: 200px; top: 200px; } &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ /* * 拖拽box1元素 * - 拖拽的流程 * 1.当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove * 3.当鼠标松开时，被拖拽元素固定在当前位置 onmouseup */ //获取box1 var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var img1 = document.getElementById(\"img1\"); //开启box1的拖拽 drag(box1); //开启box2的 drag(box2); drag(img1); }; /* * 提取一个专门用来设置拖拽的函数 * 参数：开启拖拽的元素 */ function drag(obj){ //当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown obj.onmousedown = function(event){ //设置box1捕获所有鼠标按下的事件 /* * setCapture() * - 只有IE支持，但是在火狐中调用时不会报错， * 而如果使用chrome调用，会报错 */ /*if(box1.setCapture){ box1.setCapture(); }*/ obj.setCapture &amp;&amp; obj.setCapture(); event = event || window.event; //div的偏移量 鼠标.clentX - 元素.offsetLeft //div的偏移量 鼠标.clentY - 元素.offsetTop var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //为document绑定一个onmousemove事件 document.onmousemove = function(event){ event = event || window.event; //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove //获取鼠标的坐标 var left = event.clientX - ol; var top = event.clientY - ot; //修改box1的位置 obj.style.left = left+\"px\"; obj.style.top = top+\"px\"; }; //为document绑定一个鼠标松开事件 document.onmouseup = function(){ //当鼠标松开时，被拖拽元素固定在当前位置 onmouseup //取消document的onmousemove事件 document.onmousemove = null; //取消document的onmouseup事件 document.onmouseup = null; //当鼠标松开时，取消对事件的捕获 obj.releaseCapture &amp;&amp; obj.releaseCapture(); }; /* * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， * 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为， * 如果不希望发生这个行为，则可以通过return false来取消默认行为 * * 但是这招对IE8不起作用 */ return false; }; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 我是一段文字 &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;img src=\"img/an.jpg\" id=\"img1\" style=\"position: absolute;\"/&gt; &lt;/body&gt; &lt;/html&gt; 滚轮事件： onwheel都支持 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #box1{ width: 100px; height: 100px; background-color: red; } &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ //获取id为box1的div var box1 = document.getElementById(\"box1\"); //为box1绑定一个鼠标滚轮滚动的事件 /* * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发， * 但是火狐不支持该属性 * * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件 * 注意该事件需要通过addEventListener()函数来绑定 */ box1.onmousewheel = function(event){ event = event || window.event; //event.wheelDelta 可以获取鼠标滚轮滚动的方向 //向上滚 120 向下滚 -120 //wheelDelta这个值我们不看大小，只看正负 //alert(event.wheelDelta); //wheelDelta这个属性火狐中不支持 //在火狐中使用event.detail来获取滚动的方向 //向上滚 -3 向下滚 3 //alert(event.detail); /* * 当鼠标滚轮向下滚动时，box1变长 * 当滚轮向上滚动时，box1变短 */ //判断鼠标滚轮滚动的方向 if(event.wheelDelta &gt; 0 || event.detail &lt; 0){ //向上滚，box1变短 box1.style.height = box1.clientHeight - 10 + \"px\"; }else{ //向下滚，box1变长 box1.style.height = box1.clientHeight + 10 + \"px\"; } /* * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false * 需要使用event来取消默认行为event.preventDefault(); * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错 */ event.preventDefault &amp;&amp; event.preventDefault(); /* * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动， * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 */ return false; }; //为火狐绑定滚轮事件 bind(box1,\"DOMMouseScroll\",box1.onmousewheel); }; function bind(obj , eventStr , callback){ if(obj.addEventListener){ //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); }else{ /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function(){ //在匿名函数中调用回调函数 callback.call(obj); }); } } &lt;/script&gt; &lt;/head&gt; &lt;body style=\"height: 2000px;\"&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 键盘事件键盘事件：onkeydown按键被按下对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。onkeyup按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document keyCode 可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下除了keyCode，事件对象中还提供了几个属性altKeyctrlKeyshiftKey这个三个用来判断alt ctrl 和 shift是否被按下如果按下则返回true，否则返回false //console.log(event.keyCode); //判断一个y是否被按下 //判断y和ctrl是否同时被按下 if(event.keyCode === 89 &amp;&amp; event.ctrlKey){ console.log(\"ctrl和y都被按下了\"); } input.onkeydown = function(event) { event = event || window.event; //数字 48 - 57 //使文本框中不能输入数字 if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57) { //在文本框中输入内容，属于onkeydown的默认行为 //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 return false; } }; BOM浏览器对象模型(browser object model)BOM可以使我们通过JS来操作浏览器在BOM中为我们提供了一组对象，用来完成对浏览器的操作BOM对象Window代表的是整个浏览器的窗口，同时window也是网页中的全局对象Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器Location代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面History代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页而且该操作只在当次访问时有效Screen代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用 Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了一般我们只会使用userAgent来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent 火狐的userAgentMozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0 Chrome的userAgentMozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36 IE8Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE9Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE10Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE11Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了 alert(navigator.appName); var ua = navigator.userAgent; console.log(ua); if(firefoxi.test(ua)){ alert(\"你是火狐！！！\"); }else if(chromei.test(ua)){ alert(\"你是Chrome\"); }else if(msiei.test(ua)){ alert(\"你是IE浏览器~~~\"); }else if(\"ActiveXObject\" in window){ alert(\"你是IE11，枪毙了你~~~\"); } History对象可以用来操作浏览器向前或向后翻页length属性，可以获取到当成访问的链接数量back()可以用来回退到上一个页面，作用和浏览器的回退按钮一样forward()可以跳转下一个页面，作用和浏览器的前进按钮一样go()可以用来跳转到指定的页面它需要一个整数作为参数1:表示向前跳转一个页面 相当于forward()2:表示向前跳转两个页面-1:表示向后跳转一个页面-2:表示向后跳转两个页面 Location该对象中封装了浏览器的地址栏的信息如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）alert(location);如果直接将location属性修改为一个完整的路径，或相对路径则我们页面会自动跳转到该路径，并且会生成相应的历史记录location = “http:www.baidu.com“;location = “01.BOM.html”;assign()用来跳转到其他的页面，作用和直接修改location一样reload()用于重新加载当前页面，作用和刷新按钮一样如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面location.reload(true);replace()可以使用一个新的页面替换当前页面，调用完毕也会跳转页面不会生成历史记录，不能使用回退按钮回退 window定时器setInterval()定时调用可以将一个函数，每隔一段时间执行一次参数：1.回调函数，该函数会每隔一段时间被调用一次2.每次调用间隔的时间，单位是毫秒 返回值：返回一个Number类型的数据这个数字用来作为定时器的唯一标识clearInterval()可以用来关闭一个定时器方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 clearInterval()可以接收任意参数，如果参数是一个有效的定时器的标识，则停止对应的定时器如果参数不是一个有效的标识，则什么也不做 var num = 1; var timer = setInterval(function() { count.innerHTML = num++; if(num == 11) { //关闭定时器 clearInterval(timer); } }, 1000); 延时调用setTimeout 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 var timer = setTimeout(function(){console.log(num++);},3000); 使用clearTimeout()来关闭一个延时调用clearTimeout(timer); #类的操作 直接修改元素的类css： 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式 我们可以通过修改元素的class属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离 box.className += \" b2\"; //注意有空格，添加class属性 //定义一个函数，用来向一个元素中添加指定的class属性值 /* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 * */ function addClass(obj, cn) { if (!hasClass(obj, cn)) { obj.className += \" \" + cn; } } /* * 判断一个元素中是否含有指定的class属性值 * 如果有该class，则返回true，没有则返回false * */ function hasClass(obj, cn) { var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); return reg.test(obj.className); } /* * 删除一个元素中的指定的class属性 */ function removeClass(obj, cn) { //创建一个正则表达式 var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); //删除class obj.className = obj.className.replace(reg, \"\"); } /* * toggleClass可以用来切换一个类 * 如果元素中具有该类，则删除 * 如果元素中没有该类，则添加 */ function toggleClass(obj , cn){ //判断obj中是否含有cn if(hasClass(obj , cn)){ //有，则删除 removeClass(obj , cn); }else{ //没有，则添加 addClass(obj , cn); } } JSONJavaScript Object Notation JS对象表示法 JSON 格式 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 JS中的对象只有JS自己认识，其他的语言都不认识JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号其他的和JS语法一致JSON分类：1.对象 {}2.数组 [] JSON中允许的值：1.字符串2.数值3.布尔值4.null5.对象6.数组 举例： var arr = '[1,2,3,\"hello\",true]'; var obj2 = '{\"arr\":[1,2,3]}'; var arr2 ='[{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"},{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}]'; JSON工具类 json &gt; js对象JSON.parse()可以将以JSON字符串转换为js对象它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 var o = JSON.parse(json);var o2 = JSON.parse(arr); var obj3 = {name:”猪八戒” , age:28 , gender:”男”}; JS对象 &gt; JSONJSON.stringify() -ify/fy，表示”使……化。可以将一个JS对象转换为JSON字符串需要一个js对象作为参数，会返回一个JSON字符串 var str = JSON.stringify(obj3);console.log(str); JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错 otherlocalStorage只读的localStorage 属性允许你访问一个Document 源（origin）的对象 Storage；其存储的数据能在跨浏览器会话保留。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。 eval()eval()这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回如果使用eval()执行的字符串中含有{},它会将{}当成是代码块如果不希望将其当成代码块解析，则需要在字符串前后各加一个() eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 var str = '{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}'; var obj = eval(\"(\"+str+\")\"); 编码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; confirm()用于弹出一个带有确认和取消按钮的提示框需要一个字符串作为参数，该字符串将会作为提示文字显示出来如果用户点击确认则会返回true，如果点击取消则返回falsevar flag = confirm(“确认删除”+name+”吗?”); # 原生js原生js实现复制内容到剪切板copy() { const input = document.createElement(\"input\"); document.body.appendChild(input); input.setAttribute(\"value\",this.solution.code); input.select(); if (document.execCommand(\"copy\")) { document.execCommand(\"copy\"); // console.log(\"复制成功\"); } document.body.removeChild(input); }","categories":[{"name":"js","slug":"js","permalink":"http://www.nnxx.me/categories/js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.nnxx.me/tags/JavaScript/"}]},{"title":"漫长而又快","slug":"feel","date":"2021-01-16T00:05:50.000Z","updated":"2023-04-23T09:04:14.574Z","comments":true,"path":"posts/405df2f9.html","link":"","permalink":"http://www.nnxx.me/posts/405df2f9.html","excerpt":"","text":"经过几天的折腾，终于有了一点进展，雏形已经出来了，剩下的就是需要修改的部分。恍惚几天就过去了，才发现走了许多弯路，如果自己不过于追寻那样的主题，也许很快就搭建完了。可是我没有，但在今后，我得抓紧打基础，一步一个脚印的走，向更远奔跑。不能钻牛角尖，学会放手，过段时间再去研究，可能就有不同的效果。沉稳，冷静，细心。加油！ 希望和悲伤，都是一缕光。","categories":[{"name":"js","slug":"js","permalink":"http://www.nnxx.me/categories/js/"}],"tags":[{"name":"feel","slug":"feel","permalink":"http://www.nnxx.me/tags/feel/"},{"name":"感受","slug":"感受","permalink":"http://www.nnxx.me/tags/%E6%84%9F%E5%8F%97/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://www.nnxx.me/categories/%E5%B7%A5%E5%85%B7/"},{"name":"frp","slug":"frp","permalink":"http://www.nnxx.me/categories/frp/"},{"name":"开源项目","slug":"开源项目","permalink":"http://www.nnxx.me/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"vuerpess","slug":"vuerpess","permalink":"http://www.nnxx.me/categories/vuerpess/"},{"name":"图床","slug":"图床","permalink":"http://www.nnxx.me/categories/%E5%9B%BE%E5%BA%8A/"},{"name":"域名-cdn-dns","slug":"域名-cdn-dns","permalink":"http://www.nnxx.me/categories/%E5%9F%9F%E5%90%8D-cdn-dns/"},{"name":"运维","slug":"运维","permalink":"http://www.nnxx.me/categories/%E8%BF%90%E7%BB%B4/"},{"name":"hexo","slug":"hexo","permalink":"http://www.nnxx.me/categories/hexo/"},{"name":"mysql","slug":"mysql","permalink":"http://www.nnxx.me/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"http://www.nnxx.me/categories/linux/"},{"name":"js","slug":"js","permalink":"http://www.nnxx.me/categories/js/"}],"tags":[{"name":"颜色样式","slug":"颜色样式","permalink":"http://www.nnxx.me/tags/%E9%A2%9C%E8%89%B2%E6%A0%B7%E5%BC%8F/"},{"name":"frp","slug":"frp","permalink":"http://www.nnxx.me/tags/frp/"},{"name":"远程桌面","slug":"远程桌面","permalink":"http://www.nnxx.me/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"},{"name":"有趣的项目推荐","slug":"有趣的项目推荐","permalink":"http://www.nnxx.me/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/"},{"name":"扩展","slug":"扩展","permalink":"http://www.nnxx.me/tags/%E6%89%A9%E5%B1%95/"},{"name":"vuepress-theme-hope","slug":"vuepress-theme-hope","permalink":"http://www.nnxx.me/tags/vuepress-theme-hope/"},{"name":"lsky","slug":"lsky","permalink":"http://www.nnxx.me/tags/lsky/"},{"name":"兰空图床","slug":"兰空图床","permalink":"http://www.nnxx.me/tags/%E5%85%B0%E7%A9%BA%E5%9B%BE%E5%BA%8A/"},{"name":"picgo","slug":"picgo","permalink":"http://www.nnxx.me/tags/picgo/"},{"name":"typora","slug":"typora","permalink":"http://www.nnxx.me/tags/typora/"},{"name":"cdn","slug":"cdn","permalink":"http://www.nnxx.me/tags/cdn/"},{"name":"dns解析","slug":"dns解析","permalink":"http://www.nnxx.me/tags/dns%E8%A7%A3%E6%9E%90/"},{"name":"git","slug":"git","permalink":"http://www.nnxx.me/tags/git/"},{"name":"github工作流","slug":"github工作流","permalink":"http://www.nnxx.me/tags/github%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"butterfly","slug":"butterfly","permalink":"http://www.nnxx.me/tags/butterfly/"},{"name":"hexo","slug":"hexo","permalink":"http://www.nnxx.me/tags/hexo/"},{"name":"matery","slug":"matery","permalink":"http://www.nnxx.me/tags/matery/"},{"name":"后端","slug":"后端","permalink":"http://www.nnxx.me/tags/%E5%90%8E%E7%AB%AF/"},{"name":"mysql","slug":"mysql","permalink":"http://www.nnxx.me/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"http://www.nnxx.me/tags/linux/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.nnxx.me/tags/JavaScript/"},{"name":"feel","slug":"feel","permalink":"http://www.nnxx.me/tags/feel/"},{"name":"感受","slug":"感受","permalink":"http://www.nnxx.me/tags/%E6%84%9F%E5%8F%97/"}]}